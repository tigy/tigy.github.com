/** * @author  xuld * *  *  *  *  * 	// 		// // 悬浮功能// 		// /**	 // * 底层设置某项的悬停状态。该函数仅仅设置元素的 class。	 // */	// baseSetHover: function(container, value) {		// container.toggleClass('x-' + this.xtype + '-hover', value);	// },// 		// // 选择功能// 		// /**	 // * 底层获取某项的选中状态。该函数仅仅检查元素的 class。	 // */	// baseGetSelected: function (container) {		// return container.hasClass('x-' + this.xtype + '-selected');	// },// 		// /**	 // * 底层设置某项的选中状态。该函数仅仅设置元素的 class。	 // */	// baseSetSelected: function(container, value) {		// container.toggleClass('x-' + this.xtype + '-selected', value);	// },// 		// /**	 // * 当选中的项被更新后触发。	 // */	// onChange: function (old, item){		// return this.trigger('change', {			// from: old,			// to: item		// });	// },// 		// /**	 // * 当某项被选择时触发。如果返回 false， 则事件会被阻止。	 // */	// onSelect: function (item){		// return this.trigger('select', item);	// },// 		// /**	 // * 切换某一项的选择状态。	 // */	// toggleSelected: function(item) {// 		// var selected = this.getSelectedItem();// 				// item = this.childOf(item);// 				// // 如果当前项已选中，则表示反选当前的项。		// return this.setSelectedItem(selected && selected.node === item.node ? null : item);	// },// 		// /**	 // * 底层获取某项的选中状态。该函数仅仅检查元素的 class。	 // */	// isSelectable: function (item) {		// return true;	// },// 		// /**	 // * 获取当前选中项的索引。如果没有向被选中，则返回 -1 。	 // */	// getSelectedIndex: function() {		// for (var c = this.first(), i = 0 ; c; c = c.next(), i++) {			// if (this.baseGetSelected(c)) {				// return i;			// }		// }// 		// return -1;	// },// 		// /**	 // * 设置当前选中项的索引。	 // */	// setSelectedIndex: function (value) {		// return this.setSelectedItem(this.child(value));	// },// 		// /**	 // * 获取当前选中的项。如果不存在选中的项，则返回 null 。	 // */	// getSelectedItem: function () {		// for (var c = this.first() ; c; c = c.next()) {			// if (this.baseGetSelected(c)) {				// return this.itemOf(c);			// }		// }// 		// return null;	// },// 		// /**	 // * 设置某一项为选中状态。对于单选框，该函数会同时清除已有的选择项。	 // */	// setSelectedItem: function(item){// 				// // 先反选当前选择项。		// var old = this.getSelectedItem();		// if(old)			// this.baseSetSelected(this.childOf(old), false);// 				// // 选择项。		// if(this.onSelect(item) && item != null){			// this.baseSetSelected(this.childOf(item), true);		// }// 				// // 触发 onChange 事件。		// if((old ? old.node : null) !== (item ? item.node : null))			// this.onChange(old, item);// 					// return this;	// },// 		// /**	 // * 获取选中项的文本内容。	 // */	// getText: function () {		// var selectedItem = this.getSelectedItem();		// return selectedItem ? selectedItem.getText() : '';	// },// 		// /**	 // * 查找并选中指定文本内容的项。如果没有项的文本和当前项相同，则清空选择状态。	 // */	// setText: function(value) {// 				// for (var c = this.first(), item = null ; c; c = c.next()) {			// if (c.getText() === value) {				// item = c;				// break;			// }		// }// 				// return this.setSelectedItem(item);	// },// 		// /**	 // * 确保当前有至少一项被选择。	 // */	// select: function () {		// if (this.getSelectedIndex() < 0) {			// this.setSelectedIndex(0);		// }// 				// return this;	// },// 		// hoverItem: function(){// 			// },		/**	 * 选择当前选择项的下一项。	 */		// hoverNext: function(up){		// var oldIndex = this.getSelectedIndex(), 			// newIndex, 			// maxIndex = this.count() - 1,			// item,			// available = maxIndex;// 				// do {			// if(oldIndex != -1) {				// newIndex = oldIndex + ( up !== false ? 1 : -1);				// if(newIndex < 0) newIndex = maxIndex;				// else if(newIndex > maxIndex) newIndex = 0;			// } else {				// newIndex = up !== false ? 0 : maxIndex;			// }// 						// oldIndex = newIndex;// 						// item = this.item(newIndex);// 					// } while(!this.isSelectable(item) && available-- > 0);// 				// return this.hoverItem(item);	// },// 		// /**	 // * 选择当前选择项的上一项。	 // */	// hoverPrev: function(){		// return this.hoverNext(false);	// },// 	'操作节点的选中状态': '-',			    '设置选中指定项': 'a.setSelectedIndex(0)',			    '获取当前选中项的位置': 'a.getSelectedIndex()',			    '设置某项被选中': 'a.setSelectedItem(a.item(0))',			    '设置当前选中项': 'a.getSelectedItem()',			    '通过设置文本更改选中项': 'a.setText("这是通过 append 插入的")',			    '获取当前选中的文本': 'a.getText()',			    '选中下一个': 'a.selectNext()',			    '选中上一个': 'a.selectPrev()',			    '设置点击为选择事件': 'a.bindSelector("click")'imports("Controls.Core.ScrollableControl");using("System.Data.Collection");using("Controls.Core.Base");/** * 表示一个含有滚动区域的控件。 * @class ScrollableControl * @extends Control * @abstract * @see ScrollableControl.ControlCollection * @see ListControl * @see ContainerControl * <p> * {@link ScrollableControl} 提供了完整的子控件管理功能。 * {@link ScrollableControl} 通过 {@link ScrollableControl.ControlCollection} 来管理子控件。 * 通过 {@link#controls} 属性可以获取其实例对象。 * </p> * * <p> * 通过 {@link ScrollableControl.ControlCollection#add} * 来增加一个子控件，该方法间接调用 {@link ScrollableControl.ControlCollection#onControlAdded}，以 * 让 {@link ScrollableControl} 有能力自定义组件的添加方式。 * </p> * * <p> * 如果需要创建一个含子控件的控件，则可以 继承 {@link ScrollableControl} 类创建。 * 子类需要重写 {@link #initChildControl} 方法用于对子控件初始化。 * 重写 {@link #onControlAdded}实现子控件的添加方式（默认使用 appendChild 到跟节点）。 * 重写 {@link #onControlRemoved}实现子控件的删除方式。 * 重写 {@link #createChildCollection} 实现创建自定义的容器对象。 * </p> * * <p> * 最典型的 {@link ScrollableControl} 的子类为 {@link ListControl} 和 {@link ContainerControl} 提供抽象基类。 * </p> */var ScrollableControl = Control.extend({	/**	 * 当新控件被添加时执行。	 * @param {Object} childControl 新添加的元素。	 * @param {Number} index 元素被添加的位置。	 * @protected virtual	 */	onControlAdded: function(childControl, index) {		index = this.controls[index];		assert(childControl && childControl.attach, "Control.prototype.onControlAdded(childControl, index): {childControl} \u5FC5\u987B\u662F\u63A7\u4EF6\u3002", childControl);		childControl.attach(this.container.node, index ? index.node : null);	},	/**	 * 当新控件被移除时执行。	 * @param {Object} childControl 新添加的元素。	 * @param {Number} index 元素被添加的位置。	 * @protected virtual	 */	onControlRemoved: function(childControl, index) {		assert(childControl && childControl.detach, "Control.prototype.onControlRemoved(childControl, index): {childControl} \u5FC5\u987B\u662F\u63A7\u4EF6\u3002", childControl);		childControl.detach(this.container.node);	},	/**	 * 当被子类重新时，实现创建一个子控件列表。	 * @return {ScrollableControl.ControlCollection} 子控件列表。	 * @protected virtual	 */	createControlsInstance: function() {		return new ScrollableControl.ControlCollection(this);	},	// /**	// * 获取当前控件用于存放子节点的容器控件。	// * @protected virtual	// */	// getContainer: function(){	// return this;	// },	/**	 * 从 DOM 树更新 controls 属性。	 * @protected virtual	 */	init: function() {		this.container = Dom.get(this.container.node);	},	/**	 * 根据用户的输入创建一个新的子控件。	 * @param {Object} item 新添加的元素。	 * @return {Control} 一个控件，根据用户的输入决定。	 * @protected virtual	 * 默认地，如果输入字符串和DOM节点，将转为对应的控件。	 */	initChild: Dom.parse,	removeChild: function(childControl) {		return this.controls.remove(childControl);	},	insertBefore: function(newControl, childControl) {		return childControl === null ? this.controls.add(newControl) : this.controls.insert(this.controls.indexOf(childControl), newControl);	},	/**	 * 获取目前所有子控件。	 * @type {Control.ControlCollection}	 * @name controls	 */	constructor: function() {		this.container = this;		this.controls = this.createControlsInstance();		//   this.loadControls();		Control.prototype.constructor.apply(this, arguments);	},	empty: function() {		this.controls.clear();		return this;	}});///  #region ControlCollection/** * 存储控件的集合。 * @class * @extends Collection */ScrollableControl.ControlCollection = Collection.extend({	/**	 * 初始化 Control.ControlCollection 的新实例。	 * @constructor	 * @param {ScrollableControl} owner 当前集合的所属控件。	 */	constructor: function(owner) {		this.owner = owner;	},	/**	 * 当被子类重写时，初始化子元素。	 * @param {Object} item 添加的元素。	 * @return {Object} 初始化完成后的元素。	 */	initItem: function(item) {		return this.owner.initChild(item);	},	/**	 * 通知子类一个新的元素被添加。	 * @param {Object} childControl 新添加的元素。	 * @param {Number} index 元素被添加的位置。	 */	onInsert: function(childControl, index) {		// 如果控件已经有父控件。		if (childControl.parentControl) {			childControl.parentControl.controls.remove(childControl);		}		childControl.parentControl = this.owner;		// 执行控件添加函数。		this.owner.onControlAdded(childControl, index);	},	/**	 * 通知子类一个元素被移除。	 * @param {Object} childControl 新添加的元素。	 * @param {Number} index 元素被添加的位置。	 */	onRemove: function(childControl, index) {		this.owner.onControlRemoved(childControl, index);		childControl.parentControl = null;	}});/// #endregion