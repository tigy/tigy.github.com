<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>System\Core\assets\scripts\Base.js 源码</title>
		<link href="../../assets/styles/prettify.css" type="text/css" rel="stylesheet" />
		<script src="../../assets/scripts/prettify.js" type="text/javascript"></script>
		<style type="text/css">.highlight { display: block; background-color: #ddd; }</style>
</head>
<body onload="setTimeout('prettyPrint()', 0);var node = document.getElementById(location.hash.replace(/#/, ''));if(node)node.className = 'highlight';"><pre class="prettyprint lang-js">/**
 * J+ Library, 1.0
 * @projectDescription jPlusUI: 一个轻量但完整的 Web UI 组件库。
 * @copyright 2011-2012 J+ Team
 * @license The BSD License
 * @author xuld
 * @fileOverview 定义最基本的工具函数。
 * @pragma defaultExtends JPlus.Base
 */

// 可用的宏
// 	CompactMode - 兼容模式 - 支持 IE6+ FF3+ Chrome10+ Opera10.5+ Safari5+ , 若无此宏，将只支持 HTML5。
// 	Publish - 启用发布操作 - 删除 assert 、 trace 、 imports 和 using 支持。


(function (window, undefined) {

	/// #region Core

	/**
	 * document 简写。
	 * @type Document
	 */
	var document = window.document,

        /**
         * Object 简写。
         * @type Function
         */
        Object = window.Object,

		/**
		 * Array.prototype 简写。
		 * @type  Object
		 */
		ap = Array.prototype,

		/**
		 * Object.prototype.toString 简写。
		 * @type Function
		 */
		toString = Object.prototype.toString,

		/**
		 * Object.prototype.hasOwnProperty 简写。
		 * @type Function
		 */
		hasOwnProperty = Object.prototype.hasOwnProperty,

		/**
		 * 空对象。
		 * @type Object
		 */
		emptyObj = {},

		/**
		 * 包含系统有关的函数。
		 * @type Object
		 * @namespace JPlus
		 */
		JPlus = window.JPlus = {

			<span id="Base">/**
			 * 所有类的基类。
			 * @abstract class
			 * {@link JPlus.Base} 提供了全部类都具有的基本函数。
			 */</span>
			Base: Base,

			<span id="Base-prototype-Native">/**
			 * 将一个原生的 Javascript 函数对象转换为一个类。
			 * @param {Function/Class} constructor 用于转换的对象，将修改此对象，让它看上去和普通的类一样。
			 * @return {Function} 返回生成的类。
			 * @remark 转换后的类将有继承、扩展等功能。
			 * @example &lt;pre&gt;
			 * function myFunc(){}
			 * 
			 * JPlus.Native(myFunc);
			 * 
			 * // 现在可以直接使用 implement 函数了。
			 * myFunc.implement({
			 * 	  a: 2
			 * });
			 * &lt;/pre&gt;
			 */</span>
			Native: function (constructor) {

				// JPlus 创建的类和普通的 Javascript 函数的最大区别在于:
				// JPlus 创建的类还拥有 classMembers 指定的成员。
				// 因此，将普通函数转换为 JPlus 类的方法就是复制 classMembers 下的方法。
				return extend(constructor, classMembers);
			},

			<span id="Base-prototype-id">/**
			 * id种子 。
			 * @type Number
			 * @defaultValue 1
			 * @example 下例演示了 JPlus.id 的用处。
			 * &lt;pre&gt;
			 *		var uid = JPlus.id++;  // 每次使用之后执行 ++， 保证页面内的 id 是唯一的。
			 * &lt;/pre&gt;
			 */</span>
			id: 1,

			<span id="Base-prototype-version">/**
			 * 获取当前框架的版本号。
			 * @getter
			 */</span>
			version: /*@VERSION*/1.00

		},
		
		/**
		 * 类成员方法。
		 * @type Object
		 * @namespace JPlus.Base
		 */
		classMembers = {

			/**
			 * 扩展当前类的动态方法。
			 * @param {Object} members 用于扩展的成员列表。
			 * @return this
			 * @see #implementIf
			 * @example 以下示例演示了如何扩展 Number 类的成员。&lt;pre&gt;
			 * Number.implement({
			 *   sin: function () {
			 * 	    return Math.sin(this);
			 *  }
			 * });
			 *
			 * (1).sin();  //  Math.sin(1);
			 * &lt;/pre&gt;
			 */
			implement: function (members) {

				assert(this.prototype, &quot;MyClass.implement(members): 无法扩展当前类，因为当前类的 prototype 为空。&quot;);

				// 直接将成员复制到原型上即可 。
				Object.extend(this.prototype, members);

				return this;
			},

			/**
			 * 扩展当前类的动态方法，但不覆盖已存在的成员。
			 * @param {Object} members 成员。
			 * @return this
			 * @see #implement
			 */
			implementIf: function (members) {

				assert(this.prototype, &quot;MyClass.implementIf(members): 无法扩展当前类，因为当前类的 prototype 为空。&quot;);

				Object.extendIf(this.prototype, members);

				return this;
			},

			/**
			 * 添加当前类的动态方法，该方法基于某个属性的同名方法实现。
			 * @param {String} targetProperty 要基于的属性名。
			 * @param {String} setters=undefined 设置函数的方法名数组，用空格隔开。
			 * @param {String} getters=undefined 获取函数的方法名数组，用空格隔开。
             * @remark 使用此函数只能传递最多 3 个参数。
			 * @example &lt;pre&gt;
			 * MyClass.defineMethods('field', 'fn1 fn2 fn3');
			 * &lt;/pre&gt;
			 * 等价于 &lt;pre&gt;
			 * MyClass.implement({
			 * 		fn1:  function(){ 
			 * 			return this.field.fn1();  
			 * 		},
			 * 		fn2:  function(){ 
			 * 			return this.field.fn2();  
			 * 		},
			 * 		fn3:  function(){ 
			 * 			this.field.fn();
			 * 			return this;
			 * 		}
			 * 	// 如果源函数返回 this, 将更新为当前的 this 。
			 * });
			 * &lt;/pre&gt;
			 */
			defineMethods: function(targetProperty, methods, args) {
				
				assert.isString(methods, &quot;MyClass.defineMethods(targetProperty, methods): {methods} ~&quot;);
				
				var propertyGetterFunc;
				
				if(/\(\)$/.test(targetProperty)){
					propertyGetterFunc = targetProperty.substr(0, targetProperty.length - 2);
				}
				
				// 最后使用 implement 添加成员。
				return this.implement(Object.map(methods, function(fnName) {
				    return function (arg0, arg1, arg2) {
						
						// 获取实际调用的函数目标对象。
						var target = propertyGetterFunc ? this[propertyGetterFunc]() : this[targetProperty],
							r;
							
						assert(target, &quot;#&quot; + targetProperty + &quot; 不能为空。&quot;);
						assert(!target || target[fnName], &quot;#&quot; + targetProperty + &quot;.&quot; + fnName + &quot;(): 不是函数。&quot;);

						r = target[fnName];
						
				        // 调用被代理的实际函数。
                        // 不能使用 .apply: IE 6/7 原生函数不是 function 。
						r = r.apply ? r.apply(target, arguments) : r(arg0, arg1, arg2);
						
						// 如果不是 getter，返回 this 链式引用。
						return target === r || r === undefined ? this : r;
					};
				}, {}), args);  // 支持 Dom.implement, 传递第二个参数。
			},

			/**
			 * 为当前类注册一个事件。
			 * @param {String} eventName 事件名。如果多个事件使用空格隔开。
			 * @param {Object} properties={} 事件信息。 具体见备注。
			 * @return this
			 * @remark
			 * 事件信息是一个JSON对象，它表明了一个事件在绑定、删除和触发后的一些操作。
			 *
			 * 事件信息的原型如:
			 * &lt;pre&gt;
			 * ({
			 *
			 *  // 当用户执行 target.on(type, fn) 时执行下列函数:
			 * 	add: function(target, type, fn){
			 * 		// 其中 target 是目标对象，type是事件名， fn是执行的函数。
			 *  },
			 *
			 *  // 当用户执行 target.un(type, fn) 时执行下列函数:
			 *  remove: function(target, type, fn){
			 * 		// 其中 target 是目标对象，type是事件名， fn是执行的函数。
			 *  },
			 *
			 *  // 当用户执行 target.trigger(e) 时执行下列函数:
			 *  dispatch: function(target, type, fn, e){
			 * 		// 其中 target 是目标对象，type是事件名， fn是执行的函数。e 是参数。
			 *  }
			 *
			 * });
			 * &lt;/pre&gt;
			 *
			 * 当用户使用 obj.on('事件名', 函数) 时， 系统会判断这个事件是否已经绑定过， 如果之前未绑定事件，则会创建新的函数
			 * evtTrigger， evtTrigger 函数将遍历并执行 evtTrigger.handlers 里的成员,
			 * 如果其中一个函数执行后返回 false， 则中止执行，并返回 false， 否则返回 true。
			 * evtTrigger.handlers 表示 当前这个事件的所有实际调用的函数的数组。
			 * 然后系统会调用 add(obj, '事件名', evtTrigger) 然后把 evtTrigger 保存在 obj.dataField().$event['事件名'] 中。
			 * 如果 之前已经绑定了这个事件，则 evtTrigger 已存在，无需创建。 这时系统只需把 函数 放到 evtTrigger.handlers 即可。
			 *
			 * 真正的事件触发函数是 evtTrigger， evtTrigger会执行 initEvent 和用户定义的一个事件全部函数。
			 *
			 * 当用户使用 obj.un('事件名', 函数) 时， 系统会找到相应 evtTrigger， 并从
			 * evtTrigger.handlers 删除 函数。 如果 evtTrigger.handlers 是空数组， 则使用
			 * remove(obj, '事件名', evtTrigger) 移除事件。
			 *
			 * 当用户使用 obj.trigger(参数) 时， 系统会找到相应 evtTrigger， 如果事件有trigger， 则使用
			 * dispatch(obj, '事件名', evtTrigger, 参数) 触发事件。 如果没有， 则直接调用
			 * evtTrigger(参数)。
			 *
			 * 下面分别介绍各函数的具体内容。
			 *
			 * add 表示 事件被绑定时的操作。 原型为:
			 *
			 * &lt;pre&gt;
			 * function add(elem, type, fn) {
			 * 	   // 对于标准的 DOM 事件， 它会调用 elem.addEventListener(type, fn, false);
			 * }
			 * &lt;/pre&gt;
			 *
			 * elem表示绑定事件的对象，即类实例。 type 是事件类型， 它就是事件名，因为多个事件的 add 函数肯能一样的，
			 * 因此 type 是区分事件类型的关键。fn 则是绑定事件的函数。
			 *
			 * remove 类似 add。
			 *
			 * $default 是特殊的事件名，它的各个信息将会覆盖同类中其它事件未定义的信息。
			 *
			 * @example 下面代码演示了如何给一个类自定义事件，并创建类的实例，然后绑定触发这个事件。
			 * &lt;pre&gt;
			 * // 创建一个新的类。
			 * var MyCls = new Class();
			 *
			 * MyCls.addEvents('click', {
			 *
			 * 		add:  function (elem, type, fn) {
			 * 	   		alert(&quot;为  elem 绑定 事件 &quot; + type );
			 * 		}
			 *
			 * });
			 *
			 * var m = new MyCls;
			 * m.on('myEvt', function () {  //  输出 为  elem 绑定 事件  myEvt
			 * 	  alert(' 事件 触发 ');
			 * });
			 *
			 * m.trigger('myEvt', 2);
			 *
			 * &lt;/pre&gt;
			 */
			addEvents: function (eventName, properties) {

				assert.isString(eventName, &quot;MyClass.addEvents(eventName, properties): {eventName} ~&quot;);
				
				// 获取存储事件信息的变量。如果不存在则创建。
				var eventObj = this.$event || (this.$event = {}),
					defaultEvent = eventObj.$default;
					
				if(properties) {
					Object.extendIf(properties, defaultEvent);
					
					// 处理 base: 'event' 字段，自动生成 add 和 remove 函数。
					if(properties.base) {
						assert(defaultEvent, &quot;使用 base 字段功能必须预先定义 $default 事件。&quot;);
						properties.add = function(obj, type, fn){
							defaultEvent.add(obj, this.base, fn);
						};
						
						properties.remove = function(obj, type, fn){
							defaultEvent.remove(obj, this.base, fn);
						};
					}
				} else {
					properties = defaultEvent || emptyObj;
				}

				// 将 eventName 指定的事件对象都赋值为 properties。
				Object.map(eventName, properties, eventObj);

				return this;
			},

			/**
			 * 继承当前类创建并返回子类。
			 * @param {Object/Function} [methods] 子类的员或构造函数。
			 * @return {Function} 返回继承出来的子类。
			 * @remark
			 * 在 Javascript 中，继承是依靠原型链实现的， 这个函数仅仅是对它的包装，而没有做额外的动作。
			 *
			 * 成员中的 constructor 成员 被认为是构造函数。
			 *
			 * 这个函数实现的是 单继承。如果子类有定义构造函数，则仅调用子类的构造函数，否则调用父类的构造函数。
			 *
			 * 要想在子类的构造函数调用父类的构造函数，可以使用 {@link JPlus.Base#base} 调用。
			 *
			 * 这个函数返回的类实际是一个函数，但它被 {@link JPlus.Native} 修饰过。
			 *
			 * 由于原型链的关系， 肯能存在共享的引用。 如: 类 A ， A.prototype.c = []; 那么，A的实例 b ,
			 * d 都有 c 成员， 但它们共享一个 A.prototype.c 成员。 这显然是不正确的。所以你应该把 参数 quick
			 * 置为 false ， 这样， A创建实例的时候，会自动解除共享的引用成员。 当然，这是一个比较费时的操作，因此，默认
			 * quick 是 true 。
			 *
			 * 也可以把动态成员的定义放到 构造函数， 如: this.c = []; 这是最好的解决方案。
			 *
			 * @example 下面示例演示了如何创建一个子类。
			 * &lt;pre&gt;
			 * var MyClass = new Class(); //创建一个类。
			 *
			 * var Child = MyClass.extend({  // 创建一个子类。
			 * 	  type: 'a'
			 * });
			 *
			 * var obj = new Child(); // 创建子类的实例。
			 * &lt;/pre&gt;
			 */
			extend: function (members) {

			    // 未指定函数 使用默认构造函数(Object.prototype.constructor);

				// 生成子类 。
			    var subClass = members &amp;&amp; members.hasOwnProperty(&quot;constructor&quot;) ? members.constructor : function () {

					// 调用父类构造函数 。
					arguments.callee.base.apply(this, arguments);

				};

				// 代理类 。
				emptyFn.prototype = (subClass.base = this).prototype;

				// 指定成员 。
				subClass.prototype = Object.extend(new emptyFn, members);

				// 覆盖构造函数。
				subClass.prototype.constructor = subClass;

				// 清空临时对象。
				emptyFn.prototype = null;

				// 创建类 。
				return JPlus.Native(subClass);

			}

		};

	/// #endregion

	/// #region Functions

	<span id="Object">/**
	 * 系统原生的对象。
	 * @static class Object
	 */</span>
	extend(Object, {

		/// #if CompactMode

		<span id="Object-extend">/**
		 * 复制对象的所有属性到其它对象。
		 * @param {Object} dest 复制的目标对象。
		 * @param {Object} src 复制的源对象。
		 * @return {Object} 返回 *dest*。
		 * @see Object.extendIf
		 * @example &lt;pre&gt;
	     * var a = {v: 3}, b = {g: 2};
	     * Object.extend(a, b);
	     * trace(a); // {v: 3, g: 2}
	     * &lt;/pre&gt;
		 */</span>
		extend: (function () {
			for (var item in {
				toString: 1
			})
				return extend;

			JPlus.enumerables = &quot;toString hasOwnProperty valueOf constructor isPrototypeOf&quot;.split(' ');
			// IE6 不会遍历系统对象需要复制，所以强制去测试，如果改写就复制 。
			return function (dest, src) {
				if (src) {
					assert(dest != null, &quot;Object.extend(dest, src): {dest} 不可为空。&quot;, dest);

					for (var i = JPlus.enumerables.length, value; i--;)
						if (hasOwnProperty.call(src, value = JPlus.enumerables[i]))
							dest[value] = src[value];
					extend(dest, src);
				}

				return dest;
			}
		})(),

		/// #else

		/// extend: extend,

		/// #endif

		<span id="Object-extendIf">/**
		 * 复制对象的所有属性到其它对象，但不覆盖原对象的相应值。
		 * @param {Object} dest 复制的目标对象。
		 * @param {Object} src 复制的源对象。
		 * @return {Object} 返回 *dest*。
		 * @see Object.extend
		 * @example
		 * &lt;pre&gt;
	     * var a = {v: 3, g: 5}, b = {g: 2};
	     * Object.extendIf(a, b);
	     * trace(a); // {v: 3, g: 5}  b 未覆盖 a 任何成员。
	     * &lt;/pre&gt;
		 */</span>
		extendIf: function (dest, src) {

			assert(dest != null, &quot;Object.extendIf(dest, src): {dest} 不可为空。&quot;, dest);

			// 和 extend 类似，只是判断目标的值，如果不是 undefined 然后拷贝。
			for (var b in src)
				if (dest[b] === undefined)
					dest[b] = src[b];
			return dest;
		},

		<span id="Object-each">/**
		 * 遍历一个类数组，并对每个元素执行函数 *fn*。
		 * @param {Function} fn 对每个元素运行的函数。函数的参数依次为:
		 *
		 * - {Object} value 当前元素的值。
		 * - {Number} index 当前元素的索引。
		 * - {Array} array 当前正在遍历的数组。
		 *
		 * 可以让函数返回 **false** 来强制中止循环。
		 * @param {Object} [scope] 定义 *fn* 执行时 **this** 的值。
		 * @return {Boolean} 如果循环是因为 *fn* 返回 **false** 而中止，则返回 **false**， 否则返回 **true**。
		 * @see Array#each
		 * @see Array#forEach
		 * @example
		 * &lt;pre&gt;
	     * Object.each({a: '1', c: '3'}, function (value, key) {
	     * 		trace(key + ' : ' + value);
	     * });
	     * // 输出 'a : 1' 'c : 3'
	     * &lt;/pre&gt;
		 */</span>
		each: function (iterable, fn, scope) {

			assert(typeof iterable !== 'function', &quot;Object.each(iterable, fn, scope): {iterable} 不能是函数。 &quot;, iterable);
			assert(typeof fn === 'function', &quot;Object.each(iterable, fn, scope): {fn} 必须是函数。&quot;, fn);
			
			// 如果 iterable 是 null， 无需遍历 。
			if (iterable != null) {

				// 普通对象使用 for( in ) , 数组用 0 -&gt; length 。
				if (typeof iterable.length !== &quot;number&quot;) {

					// Object 遍历。
					for (var key in iterable)
						if (fn.call(scope, iterable[key], key, iterable) === false)
							return false;
				} else {
					return each.call(iterable, fn, scope);
				}

			}

			// 正常结束返回 true。
			return true;
		},

		<span id="Object-map">/**
		 * 遍历一个类数组对象并调用指定的函数，返回每次调用的返回值数组。
		 * @param {Array/String/Object} iterable 任何对象，不允许是函数。如果是字符串，将会先将字符串用空格分成数组。
		 * @param {Function} fn 对每个元素运行的函数。函数的参数依次为:
		 *
		 * - {Object} value 当前元素的值。
		 * - {Number} index 当前元素的索引。
		 * - {Array} array 当前正在遍历的数组。
		 *
		 * @param {Object} [scope] 定义 *fn* 执行时 **this** 的值。
		 * @param {Object} [dest] 仅当 *iterable* 是字符串时，传递 *dest* 可以将函数的返回值保存到 dest。
		 * @return {Object/Undefiend} 返回的结果对象。当 *iterable* 是字符串时且未指定 dest 时，返回空。
		 * @example
		 * &lt;pre&gt;
		 * 
		 * // 传统的 map 用法:
		 * 
	     * Object.map([&quot;a&quot;,&quot;b&quot;], function(a){
	     * 	  return a + a;
	     * }); // =&gt; [&quot;aa&quot;, &quot;bb&quot;];
	     *
	     * Object.map({a: &quot;a&quot;, b: &quot;b&quot;}, function(a){
	     * 	  return a + a
	     * }); // =&gt; {a: &quot;aa&quot;, b: &quot;bb&quot;};
	     *
	     * Object.map({length: 1, &quot;0&quot;: &quot;a&quot;}, function(a){
	     * 	   return a + a
	     * }); // =&gt; [&quot;a&quot;];
	     * 
	     * // 字符串 map 用法:
	     *
	     * Object.map(&quot;a b&quot;, function(a){
	     * 		return a + a
	     * }, {}); // =&gt; {a: &quot;aa&quot;, b: &quot;bb&quot;};
	     *
	     * Object.map(&quot;a b&quot;, function(a){
	     * 		return a + a
	     * }); // =&gt; undefined; 注意: 如果未指定 dest，则结果值将丢失。
	     *
	     * Object.map(&quot;a b&quot;, 3, {}); // =&gt; {a: 3, b: 3};
	     * &lt;/pre&gt;
		 */</span>
		map: function (iterable, fn, dest) {

			var actualFn;

			// 如果是目标对象是一个字符串，则改为数组。
			if (typeof iterable === 'string') {
				iterable = iterable.split(' ');
				actualFn = typeof fn === 'function' ? dest ? function (value, key, array) {
					this[value] = fn(value, key, array);
				} : fn : function(value){
					this[value] = fn;
				}
			} else {
				dest = typeof iterable.length !== &quot;number&quot; ? {} : [];
				actualFn = function (value, key, array) {
					this[key] = fn(value, key, array);
				};
			}

			// 遍历对象。
			Object.each(iterable, actualFn, dest);

			// 返回目标。
			return dest;
		}

	});

    <span id="Object-empty">/**
     * 表示一个空函数。这个函数总是返回 undefined 。
     * @property
     * @type Function
     * @remark
     * 在定义一个类的抽象函数时，可以让其成员的值等于 **Function.empty** 。
     */</span>
	Function.empty = emptyFn;

	<span id="String-format">/**
	 * 格式化指定的字符串。
	 * @param {String} formatString 要格式化的字符串。格式化的方式见备注。
	 * @param {Object} ... 格式化用的参数。
	 * @return {String} 格式化后的字符串。
  	 * @remark 
  	 * 
  	 * 格式化字符串中，使用 {0} {1} ... 等元字符来表示传递给 String.format 用于格式化的参数。
  	 * 如 String.format(&quot;{0} 年 {1} 月 {2} 日&quot;, 2012, 12, 32) 中， {0} 被替换成 2012，
  	 * {1} 被替换成 12 ，依次类推。
  	 * 
  	 * String.format 也支持使用一个 JSON来作为格式化参数。
  	 * 如 String.format(&quot;{year} 年 {month} 月 &quot;, { year: 2012, month:12});
  	 * 若要使用这个功能，请确保 String.format 函数有且仅有 2个参数，且第二个参数是一个 Object。
  	 * 
  	 * 格式化的字符串{}不允许包含空格。
  	 * 
  	 * 默认地，String.format 将使用函数的作用域(默认为 String) 函数将参数格式化为字符串后填入目标字符串。
  	 * 因此在使用 String.format 时，应该保证 String.format 的作用域为 String 或其它格式化函数。
  	 * 
  	 * 如果需要在格式化字符串中出现 { 和 }，请分别使用 {{ 和 }} 替代。
	 * 不要出现{{{ 和 }}} 这样将获得不可预知的结果。
	 * @memberOf String
	 * @example &lt;pre&gt;
	 *  String.format(&quot;{0}转换&quot;, 1); //  &quot;1转换&quot;
	 *  String.format(&quot;{1}翻译&quot;,0,1); // &quot;1翻译&quot;
	 *  String.format(&quot;{a}翻译&quot;,{a:&quot;也可以&quot;}); // 也可以翻译
	 *  String.format(&quot;{{0}}不转换, {0}转换&quot;, 1); //  &quot;{0}不转换1转换&quot;
	 * &lt;/pre&gt;
	 */</span>
	String.format = function (formatString, args) {

		assert(!formatString || formatString.replace, 'String.format(formatString, args): {formatString} 必须是字符串。', formatString);

		// 支持参数2为数组或对象的直接格式化。
		var toString = this;

		args = arguments.length === 2 &amp;&amp; args &amp;&amp; typeof args === 'object' ? args : ap.slice.call(arguments, 1);

		// 通过格式化返回
		return formatString ? formatString.replace(/\{+?(\S*?)\}+/g, function (match, name) {
			var start = match.charAt(1) == '{', end = match.charAt(match.length - 2) == '}';
			if (start || end)
				return match.slice(start, match.length - end);
			return name in args ? toString(args[name]) : &quot;&quot;;
		}) : &quot;&quot;;
	};

    <span id="Array">/**
	 * 系统原生的数组对象。
	 * @class Array
	 */</span>
	if (!Array.isArray) {


	    <span id="Array-prototype-isArray">/**
		 * 判断一个变量是否是数组。
		 * @param {Object} obj 要判断的变量。
		 * @return {Boolean} 如果是数组，返回 true， 否则返回 false。
		 * @example
		 * &lt;pre&gt;
	     * Array.isArray([]); // true
	     * Array.isArray(document.getElementsByTagName(&quot;div&quot;)); // false
	     * Array.isArray(new Array); // true
	     * &lt;/pre&gt;
		 */</span>
	    Array.isArray = function (obj) {
	        return toString.call(obj) === &quot;[object Array]&quot;;
	    }

	}

	/// #if CompactMode

	/**
	 * 系统原生的日期对象。
	 * @class Date
	 */
	if (!Date.now) {

		<span id="Date-now">/**
		 * 获取当前时间的数字表示。
		 * @return {Number} 当前的时间点。
		 * @static
		 * @example
		 * &lt;pre&gt;
		 * Date.now(); //   相当于 new Date().getTime()
		 * &lt;/pre&gt;
		 */</span>
		Date.now = function () {
			return +new Date;
		};

	}

	/// #endif

	/**
	 * @namespace window
	 */

	<span id="Class">/**
	 * 创建一个类。
	 * @param {Object/Function} [methods] 类成员列表对象或类构造函数。
	 * @return {Function} 返回创建的类。
	 * @see JPlus.Base
	 * @see JPlus.Base.extend
	 * @example 以下代码演示了如何创建一个类:
	 * &lt;pre&gt;
	 * var MyCls = Class({
	 *
	 *    constructor: function (a, b) {
	 * 	      alert('构造函数执行了 ' + a + b);
	 *    },
	 *
	 *    say: function(){
	 *    	alert('调用了 say 函数');
	 *    }
	 *
	 * });
	 *
	 *
	 * var c = new MyCls('参数1', '参数2');  // 创建类。
	 * c.say();  //  调用 say 方法。
	 * &lt;/pre&gt;
	 */</span>
	window.Class = function (members) {
		
		// 所有类都是继承 JPlus.Base 创建的。
		return Base.extend(members);
	};

	if (!window.execScript) {

		<span id="execScript">/**
		 * 在全局作用域运行一个字符串内的代码。
		 * @param {String} statement Javascript 语句。
		 * @example
		 * &lt;pre&gt;
		 * execScript('alert(&quot;hello&quot;)');
		 * &lt;/pre&gt;
		 */</span>
		window.execScript = function (statements) {

			assert.isString(statements, &quot;execScript(statements): {statements} ~&quot;);

			// 如果正常浏览器，使用 window.eval 。
			window[&quot;eval&quot;].call(window, statements);

		};

	}

	/// #endregion

	/// #region Navigator

	<span id="navigator">/**
	 * 系统原生的浏览器对象实例。
	 * @type Navigator
	 * @namespace navigator
	 */</span>
	(function (navigator) {

		// 检查信息
		var ua = navigator.userAgent,

			match = ua.match(/(IE|Firefox|Chrome|Safari|Opera)[\/\s]([\w\.]*)/i) || ua.match(/(WebKit|Gecko)[\/\s]([\w\.]*)/i) || [0, &quot;&quot;, 0],

			// 浏览器名字。
			browser = match[1],
			
			// IE678 = false, 其它 = true
			isStd = !!+&quot;\v1&quot;;

		navigator[&quot;is&quot; + browser] = navigator[&quot;is&quot; + browser + parseInt(match[2])] = true;

		<span id="navigator-isIE">/**
		 * 获取一个值，该值指示是否为 IE 浏览器。
		 * @getter isIE
		 * @type Boolean
		 */</span>

		<span id="navigator-isIE6">/**
		 * 获取一个值，该值指示是否为 IE6 浏览器。
		 * @getter isIE6
		 * @type Boolean
		 */</span>

		<span id="navigator-isIE7">/**
		 * 获取一个值，该值指示是否为 IE7 浏览器。
		 * @getter isIE7
		 * @type Boolean
		 */</span>

		<span id="navigator-isIE8">/**
		 * 获取一个值，该值指示是否为 IE8 浏览器。
		 * @getter isIE8
		 * @type Boolean
		 */</span>

		<span id="navigator-isIE9">/**
		 * 获取一个值，该值指示是否为 IE9 浏览器。
		 * @getter isIE9
		 * @type Boolean
		 */</span>

		<span id="navigator-isIE10">/**
		 * 获取一个值，该值指示是否为 IE10 浏览器。
		 * @getter isIE10
		 * @type Boolean
		 */</span>

		<span id="navigator-isFirefox">/**
		 * 获取一个值，该值指示是否为 Firefox 浏览器。
		 * @getter isFirefox
		 * @type Boolean
		 */</span>

		<span id="navigator-isChrome">/**
		 * 获取一个值，该值指示是否为 Chrome 浏览器。
		 * @getter isChrome
		 * @type Boolean
		 */</span>

		<span id="navigator-isOpera">/**
		 * 获取一个值，该值指示是否为 Opera 浏览器。
		 * @getter isOpera
		 * @type Boolean
		 */</span>

		<span id="navigator-isOpera10">/**
		 * 获取一个值，该值指示是否为 Opera10 浏览器。
		 * @getter isOpera10
		 * @type Boolean
		 */</span>

		<span id="navigator-isSafari">/**
		 * 获取一个值，该值指示是否为 Safari 浏览器。
		 * @getter isSafari
		 * @type Boolean
		 */</span>

		// 结果
		extend(navigator, {

			/// #if CompactMode

			<span id="navigator-isStd">/**
			 * 判断当前浏览器是否符合W3C标准。
			 * @getter
			 * @type Boolean
			 * @remark 就目前浏览器状况， 除了 IE6, 7, 8， 其它浏览器都返回 true。
			 */</span>
			isStd: isStd,

			<span id="navigator-isQuirks">/**
			 * 获取一个值，该值指示当前浏览器是否支持标准事件。
			 * @getter
			 * @type Boolean
			 * @remark 就目前浏览器状况， IE6，7 中 isQuirks = true 其它浏览器都为 false 。
			 */</span>
			isQuirks: !isStd &amp;&amp; typeof document.constructor !== 'object',

			/// #endif

			<span id="navigator-name">/**
			 * 获取当前浏览器的名字。
			 * @getter
			 * @type String
			 * @remark
			 * 肯能的值有:
			 *
			 * - IE
			 * - Firefox
			 * - Chrome
			 * - Opera
			 * - Safari
			 *
			 * 对于其它非主流浏览器，返回其 HTML 引擎名:
			 *
			 * - Webkit
			 * - Gecko
			 * - Other
			 */</span>
			name: browser,

			<span id="navigator-version">/**
			 * 获取当前浏览器版本。
			 * @getter
			 * @type String
			 * @remark 输出的格式比如 6.0.0 。 这是一个字符串，如果需要比较版本，应该使用
			 * &lt;pre&gt;
			 *       parseFloat(navigator.version) &lt;= 5.5 。
			 * &lt;/pre&gt;
			 */</span>
			version: match[2]

		});

	})(window.navigator);

	/// #endregion

	/// #region Methods

	// 把所有内建对象本地化 。
	each.call([String, Array, Function, Date, Base], JPlus.Native);

	<span id="JPlus-Base">/**
	 * 所有由 new Class 创建的类的基类。
	 * @class JPlus.Base
	 */</span>
	Base.implement({

		<span id="JPlus-Base-prototype-dataField">/**
    	 * 获取当前类对应的数据字段。
    	 * @proteced virtual
    	 * @returns {Object} 一个可存储数据的对象。
    	 * @remark 默认地， 此返回返回 this 。
    	 * 此函数的意义在于将类对象和真实的数据对象分离。
    	 * 这样可以让多个类实例共享一个数据对象。
    	 * @example
    	 * &lt;pre&gt;
	     *
	     * // 创建一个类 A
	     * var A = new Class({
	     *    fn: function (a, b) {
	     * 	    alert(a + b);
	     *    }
	     * });
	     *
	     * // 创建一个变量。
	     * var a = new A();
	     *
	     * a.dataField().myData = 2;
    	 * &lt;/pre&gt;
    	 */</span>
		dataField: function () {
			return this.$data || (this.$data = {});
		},

		<span id="JPlus-Base-prototype-base">/**
	     * 调用父类的成员函数。
	     * @param {String} fnName 调用的函数名。
	     * @param {Object} [...] 调用的参数。如果不填写此项，则自动将当前函数的全部参数传递给父类的函数。
	     * @return {Object} 返回父类函数的返回值。
	     * @protected
	     * @example
	     * &lt;pre&gt;
	     *
	     * // 创建一个类 A
	     * var A = new Class({
	     *    fn: function (a, b) {
	     * 	    alert(a + b);
	     *    }
	     * });
	     *
	     * // 创建一个子类 B
	     * var B = A.extend({
	     * 	  fn: function (a, b) {
	     * 	    this.base('fn'); // 子类 B#a 调用父类 A#a
	     * 	    this.base('fn', 2, 4); // 子类 B#a 调用父类 A#a
	     *    }
	     * });
	     *
	     * new B().fn(1, 2); // 输出 3 和 6
	     * &lt;/pre&gt;
	     */</span>
		base: function (fnName) {

			var me = this.constructor,

	            fn = this[fnName],

	            oldFn = fn,

	            args = arguments;

			assert(fn, &quot;JPlus.Base#base(fnName, args): 子类不存在 {fnName} 的属性或方法。&quot;, fnName);

			// 标记当前类的 fn 已执行。
			fn.$bubble = true;

			assert(!me || me.prototype[fnName], &quot;JPlus.Base#base(fnName, args): 父类不存在 {fnName} 的方法。&quot;, fnName);

			// 保证得到的是父类的成员。

			do {
				me = me.base;
				assert(me &amp;&amp; me.prototype[fnName], &quot;JPlus.Base#base(fnName, args): 父类不存在 {fnName} 的方法。&quot;, fnName);
			} while ('$bubble' in (fn = me.prototype[fnName]));

			assert.isFunction(fn, &quot;JPlus.Base#base(fnName, args): 父类的成员 {fn}不是一个函数。  &quot;);

			fn.$bubble = true;

			// 确保 bubble 记号被移除。
			try {
				if (args.length &lt;= 1)
					return fn.apply(this, args.callee.caller.arguments);
				args[0] = this;
				return fn.call.apply(fn, args);
			} finally {
				delete fn.$bubble;
				delete oldFn.$bubble;
			}
		},

		<span id="JPlus-Base-prototype-on">/**
		 * 增加一个事件监听者。
		 * @param {String} eventName 事件名。
		 * @param {Function} eventHandler 监听函数。当事件被处罚时会执行此函数。
		 * @param {Object} scope=this *eventHandler* 执行时的作用域。
		 * @return this
		 * @example
		 * &lt;pre&gt;
	     *
	     * // 创建一个类 A
	     * var A = new Class({
	     *
	     * });
	     *
	     * // 创建一个变量。
	     * var a = new A();
	     *
	     * // 绑定一个 click 事件。
         * a.on('click', function (e) {
         * 		return true;
         * });
         * &lt;/pre&gt;
		 */</span>
		on: function (eventName, eventHandler, scope) {

			assert.isFunction(eventHandler, 'JPlus.Base#on(eventName, eventHandler, scope): {eventHandler} ~');

			// 获取本对象 本对象的数据内容 本事件值
			var me = this,
	        	data = me.dataField(),
	        	eventListener,
	        	eventManager;
			
			// 获取存储事件对象的空间。
			data = data.$event || (data.$event = {});
			
			// 获取当前事件对应的函数监听器。
			eventListener = data[eventName];
			
			// 生成默认的事件作用域。
			scope = [eventHandler, scope || me];

			// 如果未绑定过这个事件, 则不存在监听器，先创建一个有关的监听器。
			if (!eventListener) {
				
				// 获取事件管理对象。
				eventManager = getMgr(me, eventName);

				// 生成实际处理事件的监听器。
				data[eventName] = eventListener = function (e) {
					var eventListener = arguments.callee, 
						handlers = eventListener.handlers.slice(0), 
						handler,
						i = -1, 
						length = handlers.length;
					
					// 循环直到 return false。
					while (++i &lt; length) {
						handler = handlers[i];
						if (handler[0].call(handler[1], e) === false) {
							
							// 如果存在 stopEvent 处理函数，则调用。
							// 如果当前函数是因为 initEvent 返回 false 引起，则不执行 stopEvent 。
							if(handler[2] !== true &amp;&amp; (handler = eventListener.stop)){
								handler[0].call(handler[1], e);
							}
							return false;
						}
					}

					return true;
				};
				
				// 当前事件的全部函数。
				eventListener.handlers = eventManager.initEvent ? 
					[[eventManager.initEvent, me, true], scope] : 
					[scope];

				// 如果事件允许阻止，则存储字段。
				if(eventManager.stopEvent) {
					eventListener.stop = [eventManager.stopEvent, me];
				}

				// 如果事件支持自定义的添加方式，则先添加。
				if (eventManager.add) {
					eventManager.add(me, eventName, eventListener);
				}

			} else {
						
				// 添加到 handlers 。
				eventListener.handlers.push(scope);
			}


			return me;
		},

		<span id="JPlus-Base-prototype-trigger">/**
		 * 手动触发一个监听器。
		 * @param {String} eventName 监听名字。
		 * @param {Object} [e] 传递给监听器的事件对象。
		 * @return this
		 * @example &lt;pre&gt;
	     *
	     * // 创建一个类 A
	     * var A = new Class({
	     *
	     * });
	     *
	     * // 创建一个变量。
	     * var a = new A();
	     *
	     * // 绑定一个 click 事件。
         * a.on('click', function (e) {
         * 		return true;
         * });
         *
         * // 手动触发 click， 即执行  on('click') 过的函数。
         * a.trigger('click');
         * &lt;/pre&gt;
		 */</span>
		trigger: function (eventName, e) {

			// 获取本对象 本对象的数据内容 本事件值 。
			var me = this, 
				data = me.dataField().$event, 
				eventManager;

			// 执行事件。
			return !data || !(data = data[eventName]) || ((eventManager = getMgr(me, eventName)).dispatch ? eventManager.dispatch(me, eventName, data, e) : data(e));

		},

		<span id="JPlus-Base-prototype-un">/**
		 * 删除一个或多个事件监听器。
		 * @param {String} [eventName] 事件名。如果不传递此参数，则删除全部事件的全部监听器。
		 * @param {Function} [eventHandler] 回调器。如果不传递此参数，在删除指定事件的全部监听器。
		 * @return this
		 * @remark
		 * 注意: `function () {} !== function () {}`, 这意味着下列代码的 un 将失败:
		 * &lt;pre&gt;
         * elem.on('click', function () {});
         * elem.un('click', function () {});   // 无法删除 on 绑定的函数。
         * &lt;/pre&gt;
		 * 正确的做法是把函数保存起来。 &lt;pre&gt;
         * var fn =  function () {};
         * elem.on('click', fn);
         * elem.un('click', fn); // fn  被成功删除。
         *
         * 如果同一个 *eventListener* 被增加多次， un 只删除第一个。
         * &lt;/pre&gt;
		 * @example
		 * &lt;pre&gt;
	     *
	     * // 创建一个类 A
	     * var A = new Class({
	     *
	     * });
	     *
	     * // 创建一个变量。
	     * var a = new A();
	     *
	     * var fn = function (e) {
         * 		return true;
         * };
	     *
	     * // 绑定一个 click 事件。
         * a.on('click', fn);
         *
         * // 删除一个 click 事件。
         * a.un('click', fn);
         * &lt;/pre&gt;
		 */</span>
		un: function (eventName, eventHandler) {

			assert(!eventHandler || typeof eventHandler === 'function', 'JPlus.Base#un(eventName, eventHandler): {eventHandler} 必须是函数。', eventHandler);

			// 获取本对象 本对象的数据内容 本事件值
			var me = this, 
				data = me.dataField().$event, 
				eventListener, 
				handlers, 
				i;
			
			if (data) {
				
				// 获取指定事件的监听器。
				if (eventListener = data[eventName]) {
					
					// 如果删除特定的处理函数。
					// 搜索特定的处理函数。
					if (eventHandler) {

						handlers = eventListener.handlers;
						i = handlers.length;

						// 根据常见的需求，这里逆序搜索有助于提高效率。
						while (i-- &gt; 0) {
							
							if (handlers[i][0] === eventHandler) {
								
								// 删除 hander 。
								handlers.splice(i, 1);
								
								// 如果删除后只剩 0 个句柄，或只剩 1个 initEvent 句柄，则删除全部数据。
								if (!i || (i === 1 &amp;&amp; handlers[0] === true)) {
									eventHandler = 0;
								}

								break;
							}
						}

					}

					// 检查是否存在其它函数或没设置删除的函数。
					if (!eventHandler) {

						// 删除对事件处理句柄的全部引用，以允许内存回收。
						delete data[eventName];
						
						// 获取事件管理对象。
						data = getMgr(me, eventName);

						// 内部事件管理的删除。
						if (data.remove)
							data.remove(me, eventName, eventListener);
					}
				} else if (!eventName) {
					for (eventName in data)
						me.un(eventName);
				}
			}
			return me;
		},

		<span id="JPlus-Base-prototype-once">/**
		 * 增加一个仅监听一次的事件监听者。
		 * @param {String} type 事件名。
		 * @param {Function} listener 监听函数。当事件被处罚时会执行此函数。
		 * @param {Object} scope=this *listener* 执行时的作用域。
		 * @return this
		 * @example &lt;pre&gt;
	     *
	     * // 创建一个类 A
	     * var A = new Class({
	     *
	     * });
	     *
	     * // 创建一个变量。
	     * var a = new A();
	     *
         * a.once('click', function (e) {
         * 		trace('click 被触发了');
         * });
         *
         * a.trigger('click');   //  输出  click 被触发了
         * a.trigger('click');   //  没有输出
         * &lt;/pre&gt;
		 */</span>
		once: function (eventName, eventHandler, scope) {

			assert.isFunction(eventHandler, 'JPlus.Base#once(eventName, eventHandler): {eventHandler} ~');

			// 先插入一个用于删除句柄的函数。
			return this.on(eventName, function(){
				this.un(eventName, eventHandler).un(eventName, arguments.callee);	
			}).on(eventName, eventHandler, scope);
		}

	});

	<span id="String">/**
	 * 系统原生的字符串对象。
	 * @class String
	 */</span>
	String.implementIf({

		/// #if CompactMode

		<span id="String-prototype-trim">/**
		 * 去除字符串的首尾空格。
		 * @return {String} 处理后的字符串。
		 * @remark 目前除了 IE8-，主流浏览器都已内置此函数。
		 * @example
		 * &lt;pre&gt;
	     * &quot;   g h   &quot;.trim(); //  返回     &quot;g h&quot;
	     * &lt;/pre&gt;
		 */</span>
		trim: function () {
			return this.replace(/^[\s\u00A0]+|[\s\u00A0]+$/g, &quot;&quot;);
		},

		/// #endif

		<span id="String-prototype-toCamelCase">/**
		 * 将字符串转为骆驼格式。
		 * @return {String} 返回的内容。
		 * @remark
		 * 比如 &quot;awww-bwww-cwww&quot; 的骆驼格式为 &quot;awwBwwCww&quot;
		 * @example
		 * &lt;pre&gt;
	     * &quot;font-size&quot;.toCamelCase(); //     &quot;fontSize&quot;
	     * &lt;/pre&gt;
		 */</span>
		toCamelCase: function () {
			return this.replace(/-(\w)/g, toUpperCase);
		},

		<span id="String-prototype-capitalize">/**
		 * 将字符首字母大写。
		 * @return {String} 处理后的字符串。
		 * @example
		 * &lt;pre&gt;
	     * &quot;aa&quot;.capitalize(); //     &quot;Aa&quot;
	     * &lt;/pre&gt;
		 */</span>
		capitalize: function () {

			// 使用正则实现。
			return this.replace(/(\b[a-z])/g, toUpperCase);
		}

	});

	/**
	 * 系统原生的函数对象。
	 * @class Function
	 */
	Function.implementIf({

		/**
		 * 绑定函数作用域(**this**)。并返回一个新函数，这个函数内的 **this** 为指定的 *scope* 。
		 * @param {Object} scope 要绑定的作用域的值。
		 * @example
		 * &lt;pre&gt;
		 * var fn = function(){ trace(this);  };
		 *
		 * var fnProxy = fn.bind(0);
		 *
	     * fnProxy()  ; //  输出 0
	     * &lt;/pre&gt;
		 */
		bind: function (scope) {

			var me = this;
			
			// 返回对 scope 绑定。
			return function () {
				return me.apply(scope, arguments);
			}
		}

	});

	/**
	 * 系统原生的数组对象。
	 * @class Array
	 */
	Array.implementIf({

		<span id="Array-prototype-each">/**
		 * 遍历当前数组，并对数组的每个元素执行函数 *fn*。
		 * @param {Function} fn 对每个元素运行的函数。函数的参数依次为:
		 *
		 * - {Object} value 当前元素的值。
		 * - {Number} index 当前元素的索引。
		 * - {Array} array 当前正在遍历的数组。
		 *
		 * 可以让函数返回 **false** 来强制中止循环。
		 * @param {Object} [scope] 定义 *fn* 执行时 **this** 的值。
		 * @return {Boolean} 如果循环是因为 *fn* 返回 **false** 而中止，则返回 **false**， 否则返回 **true**。
		 * @method
		 * @see Object.each
		 * @see #forEach
		 * @see #filter
		 * @see Object.map
		 * @remark
		 * 在高版本浏览器中，forEach 和 each 功能大致相同，但是 forEach 不支持通过 return false 中止循环。
		 * 在低版本(IE8-)浏览器中， forEach 为 each 的别名。
		 * @example 以下示例演示了如何遍历数组，并输出每个元素的值。
		 * &lt;pre&gt;
	     * [2, 5].each(function (value, index) {
	     * 		trace(value);
	     * });
	     * // 输出 '2 5'
	     * &lt;/pre&gt;
	     *
	     * 以下示例演示了如何通过 return false 来中止循环。
	     * &lt;pre&gt;
	     * [2, 5].each(function (value, index) {
	     * 		trace(value);
	     * 		return false;
	     * });
	     * // 输出 '2'
	     * &lt;/pre&gt;
		 */</span>
		each: each,

		<span id="Array-prototype-include">/**
		 * 如果当前数组中不存在指定 *value*， 则将 *value* 添加到当前数组的末尾。
		 * @param {Object} value 要添加的值。
		 * @return {Boolean} 如果此次操作已成功添加 *value*，则返回 **true**;
		 * 否则表示原数组已经存在 *value*，返回 **false**。
		 * @example
		 * &lt;pre&gt;
	     * [&quot;&quot;, &quot;aaa&quot;, &quot;zzz&quot;, &quot;qqq&quot;].include(&quot;&quot;); // 返回 true， 数组不变。
	     * [false].include(0);	// 返回 false， 数组变为 [false, 0]
	     * &lt;/pre&gt;
		 */</span>
		include: function (value) {
			var exists = this.indexOf(value) &gt;= 0;
			if (!exists)
				this.push(value);
			return exists;
		},

		<span id="Array-prototype-invoke">/**
		 * 对当前数组的每个元素调用其指定属性名的函数，并将返回值放入新的数组返回。
		 * @param {String} fnName 要调用的函数名。
		 * @param {Array} [args] 调用时的参数数组。
		 * @return {Array} 返回包含执行结果的数组。
		 * @example
		 * &lt;pre&gt;
	     * [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;].invoke('charAt', [0]); //  ['a', 'd', 'g']
	     * &lt;/pre&gt;
		 */</span>
		invoke: function (fnName, args) {
			assert(!args || typeof args.length === 'number', &quot;Array#invoke(fnName, args): {args} 必须是参数数组。&quot;, args);
			var r = [];
			ap.forEach.call(this, function (value) {
				assert(value != null &amp;&amp; value[fnName] &amp;&amp; value[fnName].apply, &quot;Array#invoke(fnName, args): {value} 不包含函数 {fnName}。&quot;, value, fnName);
				r.push(value[fnName].apply(value, args || []));
			});

			return r;
		},

		<span id="Array-prototype-unique">/**
		 * 删除数组中重复元素。
		 * @return {Array} this
		 * @example
		 * &lt;pre&gt;
	     * [1, 7, 8, 8].unique(); //    [1, 7, 8]
	     * &lt;/pre&gt;
		 */</span>
		unique: function () {

			// 删除从 i + 1 之后的当前元素。
			for (var i = 0, j, value; i &lt; this.length;) {
				value = this[i];
				j = ++i;
				do {
					j = ap.remove.call(this, value, j);
				} while (j &gt;= 0);
			}

			return this;
		},

		<span id="Array-prototype-remove">/**
		 * 删除当前数组中指定的元素。
		 * @param {Object} value 要删除的值。
		 * @param {Number} startIndex=0 开始搜索 *value* 的起始位置。
		 * @return {Number} 被删除的值在原数组中的位置。如果要擅长的值不存在，则返回 -1 。
		 * @remark
		 * 如果数组中有多个相同的值， remove 只删除第一个。
		 * @example
		 * &lt;pre&gt;
	     * [1, 7, 8, 8].remove(7); // 返回 1,  数组变成 [7, 8, 8]
	     * &lt;/pre&gt;
	     *
	     * 以下示例演示了如何删除数组全部相同项。
	     * &lt;pre&gt;
	     * var arr = [&quot;wow&quot;, &quot;wow&quot;, &quot;J+ UI&quot;, &quot;is&quot;, &quot;powerful&quot;, &quot;wow&quot;, &quot;wow&quot;];
	     *
	     * // 反复调用 remove， 直到 remove 返回 -1， 即找不到值 wow
	     * while(arr.remove(wow) &gt;= 0);
	     *
	     * trace(arr); // 输出 [&quot;J+ UI&quot;, &quot;is&quot;, &quot;powerful&quot;]
	     * &lt;/pre&gt;
		 */</span>
		remove: function (value, startIndex) {

			// 找到位置， 然后删。
			var i = ap.indexOf.call(this, value, startIndex);
			if (i !== -1)
				ap.splice.call(this, i, 1);
			return i;
		},

		<span id="Array-prototype-item">/**
		 * 获取当前数组中指定索引的元素。
		 * @param {Number} index 要获取的元素索引。如果 *index* 小于 0， 则表示获取倒数 *index* 位置的元素。
		 * @return {Object} 指定位置所在的元素。如果指定索引的值不存在，则返回 undefined。
		 * @remark
		 * 使用 arr.item(-1) 可获取最后一个元素的值。
		 * @example
		 * &lt;pre&gt;
	     * [0, 1, 2, 3].item(0);  // 0
	     * [0, 1, 2, 3].item(-1); // 3
	     * [0, 1, 2, 3].item(5);  // undefined
	     * &lt;/pre&gt;
		 */</span>
		item: function (index) {
			return this[index &lt; 0 ? this.length + index : index];
		},

		/// #if CompactMode

		<span id="Array-prototype-indexOf">/**
		 * 返回当前数组中某个值的第一个位置。
		 * @param {Object} item 成员。
		 * @param {Number} startIndex=0 开始查找的位置。
		 * @return {Number} 返回 *vaue* 的索引，如果不存在指定的值， 则返回-1 。
		 * @remark 目前除了 IE8-，主流浏览器都已内置此函数。
		 */</span>
		indexOf: function (value, startIndex) {
			startIndex = startIndex || 0;
			for (var len = this.length; startIndex &lt; len; startIndex++)
				if (this[startIndex] === value)
					return startIndex;
			return -1;
		},

		<span id="Array-prototype-filter">/**
		 * 对数组每个元素通过一个函数过滤。返回所有符合要求的元素的数组。
		 * @param {Function} fn 对每个元素运行的函数。函数的参数依次为:
		 *
		 * - {Object} value 当前元素的值。
		 * - {Number} index 当前元素的索引。
		 * - {Array} array 当前正在遍历的数组。
		 *
		 * 如果函数返回 **true**，则当前元素会被添加到返回值数组。
		 * @param {Object} [scope] 定义 *fn* 执行时 **this** 的值。
		 * @return {Array} 返回一个新的数组，包含过滤后的元素。
		 * @remark 目前除了 IE8-，主流浏览器都已内置此函数。
		 * @see #each
		 * @see #forEach
		 * @see Object.map
		 * @example
		 * &lt;pre&gt;
	     * [1, 7, 2].filter(function (key) {
	     * 		return key &lt; 5;
	     * })  //  [1, 2]
	     * &lt;/pre&gt;
		 */</span>
		filter: function (fn, scope) {
			assert.isFunction(fn, &quot;Array#filter(fn, scope): {fn} ~&quot;);
			var r = [];
			ap.forEach.call(this, function (value, i, array) {
				if (fn.call(scope, value, i, array))
					r.push(value);
			});
			return r;
		},

		<span id="Array-prototype-forEach">/**
		 * 遍历当前数组，并对数组的每个元素执行函数 *fn*。
		 * @param {Function} fn 对每个元素运行的函数。函数的参数依次为:
		 *
		 * - {Object} value 当前元素的值。
		 * - {Number} index 当前元素的索引。
		 * - {Array} array 当前正在遍历的数组。
		 *
		 * 可以让函数返回 **false** 来强制中止循环。
		 * @param {Object} [scope] 定义 *fn* 执行时 **this** 的值。
		 * @see #each
		 * @see Object.each
		 * @see #filter
		 * @see Object.map
		 * @remark
		 * 在高版本浏览器中，forEach 和 each 功能大致相同，但是 forEach 不支持通过 return false 中止循环。
		 * 在低版本(IE8-)浏览器中， forEach 为 each 的别名。
		 *
		 * 目前除了 IE8-，主流浏览器都已内置此函数。
		 * @example 以下示例演示了如何遍历数组，并输出每个元素的值。
		 * &lt;pre&gt;
	     * [2, 5].forEach(function (value, key) {
	     * 		trace(value);
	     * });
	     * // 输出 '2' '5'
	     * &lt;/pre&gt;
		 */</span>
		forEach: each

		/// #endif

	});

	/// #endregion

	/// #region Private Functions

	/**
	 * 复制所有属性到任何对象。
	 * @param {Object} dest 复制目标。
	 * @param {Object} src 要复制的内容。
	 * @return {Object} 复制后的对象。
	 */
	function extend(dest, src) {

		assert(dest != null, &quot;Object.extend(dest, src): {dest} 不可为空。&quot;, dest);

		// 直接遍历，不判断是否为真实成员还是原型的成员。
		for (var key in src)
		    dest[key] = src[key];
		return dest;
	}

	/**
	 * 对数组运行一个函数。
	 * @param {Function} fn 遍历的函数。参数依次 value, index, array 。
	 * @param {Object} scope 对象。
	 * @return {Boolean} 返回一个布尔值，该值指示本次循环时，有无出现一个函数返回 false 而中止循环。
	 */
	function each(fn, scope) {

		assert(typeof fn === 'function', &quot;Array#each(fn, scope): {fn} 必须是一个函数。&quot;, fn);

		var i = -1, me = this;

		while (++i &lt; me.length)
			if (fn.call(scope, me[i], i, me) === false)
				return false;
		return true;
	}

	/**
	 * 所有自定义类的基类。
	 */
	function Base() {

	}

	/**
	 * 空函数。
	 */
	function emptyFn() {

	}

	/**
	 * 将一个字符转为大写。
	 * @param {String} ch 参数。
	 * @param {String} match 字符。
	 * @return {String} 转为大写之后的字符串。
	 */
	function toUpperCase(ch, match) {
		return match.toUpperCase();
	}

	/**
	 * 获取指定的对象所有的事件管理器。
	 * @param {Object} obj 要使用的对象。
	 * @param {String} type 事件名。
	 * @return {Object} 符合要求的事件管理器，如果找不到合适的，返回默认的事件管理器。
	 */
	function getMgr(obj, eventName) {
		var clazz = obj.constructor, 
			t;

		// 遍历父类，找到指定事件。
		while (!(t = clazz.$event) || !(eventName in t)) {
			if (!(clazz = clazz.base)) {
				return emptyObj;
			}
		}

		return t[eventName];
	}

	/// #endregion

})(this);

/// #if !Publish

JPlus.Base.prototype.toString = function () {
	for (var item in window) {
		if (window[item] === this.constructor)
			return item;
	}

	return Object.prototype.toString.call(this);
};

/**
 * Debug Tools
 */

<span id="trace">/**
 * 调试输出指定的信息。
 * @param {Object} ... 要输出的变量。
 */</span>
function trace() {

	// 无参数的话，自动补充一个参数。
	if (arguments.length === 0) {
		if (!trace.$count)
			trace.$count = 0;
		return trace('(trace: ' + (trace.$count++) + ')');
	}


	if (trace.enable) {

		var hasConsole = window.console, data;

		// 优先使用 console.debug
		if (hasConsole &amp;&amp; console.debug &amp;&amp; console.debug.apply) {
			return console.debug.apply(console, arguments);
		}

		// 然后使用 console.log
		if (hasConsole &amp;&amp; console.log &amp;&amp; console.log.apply) {
			return console.log.apply(console, arguments);
		}
		
		// 最后使用 trace.inspect
		for (var i = 0, r = []; i &lt; arguments.length; i++) {
			r[i] = trace.inspect(arguments[i]);
		}

		data = r.join(' ');

		return hasConsole &amp;&amp; console.log ? console.log(data) : alert(data);
	}
}

<span id="assert">/**
 * 确认一个值是 **true**，否则向用户显示一个警告。
 * @param {Object} value 要用于判断的值。它会被自动转为布尔型之后再作判断。
 * @param {String} message=&quot;断言失败&quot; 如果 *value* 为 **false**, 则显示的错误提示。
 * @param {Object} ... 用于格式化 message 中被 {} 包围的参数名的具体值。
 * @return {Boolean} 返回 *value* 的等效布尔值。
 * @example &lt;pre&gt;
 * var value = 1;
 * assert(value &gt; 0, &quot;{value} 应该大于 0。&quot;, value);
 * &lt;/pre&gt;
 */</span>
function assert(value, message) {
	if (!value) {

		var args = arguments;

		switch (args.length) {
			case 1:
				message = &quot;断言失败&quot;;
			case 2:
				break;
			case 0:
				return true;
			default:
				var i = 2;
				message = message.replace(/\{([\w\.\(\)]*?)\}/g, function (match, argsName) {
					return &quot;参数 &quot; + (args.length &lt;= i ? match : argsName + &quot; = &quot; + trace.ellipsis(trace.inspect(args[i++]), 200));
				});
		}

		// 显示调用堆栈。
		if (assert.stackTrace) {

			// 函数调用源。
			args = args.callee.caller;

			// 跳过 assert 函数。
			while (args &amp;&amp; args.debugStepThrough)
				args = args.caller;

			// 找到原调用者。
			if (args &amp;&amp; args.caller) {
				args = args.caller;
			}

			if (args)
				message += &quot;\r\n--------------------------------------------------------------------\r\n&quot; + trace.ellipsis(trace.decodeUTF8(args.toString()), 600);

		}

		window.trace.error(message);

	}

	return !!value;
}

<span id="using">/**
 * 载入一个组件的 js 和 css源码。
 * @param {String} namespace 组件全名。
 * @example &lt;pre&gt;
 * using(&quot;System.Dom.Keys&quot;);
 * &lt;/pre&gt;
 */</span>
function using(namespace, isStyle) {

	assert.isString(namespace, &quot;using(ns): {ns} 不是合法的组件全名。&quot;);

	var cache = using[isStyle ? 'styles' : 'scripts'];

	for (var i = 0; i &lt; cache.length; i++) {
		if (cache[i] === namespace)
			return;
	}

	cache.push(namespace);

	namespace = using.resolve(namespace, isStyle);

	var tagName,
    	type,
    	exts,
    	callback;

	if (isStyle) {
		tagName = &quot;LINK&quot;;
		type = &quot;href&quot;;
		exts = [&quot;.css&quot;];
		callback = using.loadStyle;

	} else {
		tagName = &quot;SCRIPT&quot;;
		type = &quot;src&quot;;
		exts = [&quot;.js&quot;];
		callback = using.loadScript;
	}

	// 如果在节点找到符合的就返回，找不到，调用 callback 进行真正的 加载处理。

	var doms = document.getElementsByTagName(tagName),
		path = namespace.replace(/^[\.\/\\]+/, &quot;&quot;);

	for (var i = 0; doms[i]; i++) {
		var url = ((document.constructor ? doms[i][type] : doms[i].getAttribute(type, 4)) || '');
		for (var j = 0; j &lt; exts.length; j++) {
			if (url.indexOf(path + exts[j]) &gt;= 0) {
				return;
			}
		}
	}

	callback(using.rootPath + namespace + exts[0]);
}

<span id="imports">/**
 * 导入指定组件全名表示的样式文件。
 * @param {String} namespace 组件全名。
 */</span>
function imports(namespace) {
	return using(namespace, true);
}

(function () {

	/// #region Trace

	/**
     * @namespace trace
     */
	extend(trace, {

		<span id="trace-enable">/**
		 * 是否打开调试输出。
		 * @config {Boolean}
		 */</span>
		enable: true,

		<span id="trace-ellipsis">/**
		 * 将字符串限定在指定长度内，超出部分用 ... 代替。
		 * @param {String} value 要处理的字符串。
		 * @param {Number} length 需要的最大长度。
		 * @example
		 * &lt;pre&gt;
	     * String.ellipsis(&quot;1234567&quot;, 6); //   &quot;123...&quot;
	     * String.ellipsis(&quot;1234567&quot;, 9); //   &quot;1234567&quot;
	     * &lt;/pre&gt;
		 */</span>
		ellipsis: function (value, length) {
			return value.length &gt; length ? value.substr(0, length - 3) + &quot;...&quot; : value;
		},

		<span id="trace-decodeUTF8">/**
         * 将字符串从 utf-8 字符串转义。
         * @param {String} s 字符串。
         * @return {String} 返回的字符串。
         */</span>
		decodeUTF8: function (s) {
			return s.replace(/\\u([0-9a-f]{3})([0-9a-f])/gi, function (a, b, c) {
				return String.fromCharCode((parseInt(b, 16) * 16 + parseInt(c, 16)))
			})
		},

		<span id="trace-api">/**
         * 输出类的信息。
         * @param {Object} [obj] 要查看成员的对象。如果未提供这个对象，则显示全局的成员。
         * @param {Boolean} showPredefinedMembers=true 是否显示内置的成员。
         */</span>
		api: (function () {

			var nodeTypes = 'Window Element Attr Text CDATASection Entity EntityReference ProcessingInstruction Comment HTMLDocument DocumentType DocumentFragment Document Node'.split(' '),

                definedClazz = 'String Date Array Number RegExp Function XMLHttpRequest Object'.split(' ').concat(nodeTypes),

                predefinedNonStatic = {
                	'Object': 'valueOf hasOwnProperty toString',
                	'String': 'length charAt charCodeAt concat indexOf lastIndexOf match quote slice split substr substring toLowerCase toUpperCase trim sub sup anchor big blink bold small fixed fontcolor italics link',
                	'Array': 'length pop push reverse shift sort splice unshift concat join slice indexOf lastIndexOf filter forEach',
                	/*
                     * every
                     * map
                     * some
                     * reduce
                     * reduceRight'
                     */
                	'Number': 'toExponential toFixed toLocaleString toPrecision',
                	'Function': 'length extend call',
                	'Date': 'getDate getDay getFullYear getHours getMilliseconds getMinutes getMonth getSeconds getTime getTimezoneOffset getUTCDate getUTCDay getUTCFullYear getUTCHours getUTCMinutes getUTCMonth getUTCSeconds getYear setDate setFullYear setHours setMinutes setMonth setSeconds setTime setUTCDate setUTCFullYear setUTCHours setUTCMilliseconds setUTCMinutes setUTCMonth setUTCSeconds setYear toGMTString toLocaleString toUTCString',
                	'RegExp': 'exec test'
                },

                predefinedStatic = {
                	'Array': 'isArray',
                	'Number': 'MAX_VALUE MIN_VALUE NaN NEGATIVE_INFINITY POSITIVE_INFINITY',
                	'Date': 'now parse UTC'
                },

                APIInfo = function (obj, showPredefinedMembers) {
                	this.members = {};
                	this.sortInfo = {};

                	this.showPredefinedMembers = showPredefinedMembers !== false;
                	this.isClass = obj === Function || (obj.prototype &amp;&amp; obj.prototype.constructor !== Function);

                	// 如果是普通的变量。获取其所在的原型的成员。
                	if (!this.isClass &amp;&amp; obj.constructor !== Object) {
                		this.prefix = this.getPrefix(obj.constructor);

                		if (!this.prefix) {
                			var nodeType = obj.replaceChild ? obj.nodeType : obj.setInterval &amp;&amp; obj.clearTimeout ? 0 : null;
                			if (nodeType) {
                				this.prefix = this.memberName = nodeTypes[nodeType];
                				if (this.prefix) {
                					this.baseClassNames = ['Node', 'Element', 'HTMLElement', 'Document'];
                					this.baseClasses = [window.Node, window.Element, window.HTMLElement, window.HTMLDocument];
                				}
                			}
                		}

                		if (this.prefix) {
                			this.title = this.prefix + this.getBaseClassDescription(obj.constructor) + &quot;的实例成员: &quot;;
                			this.prefix += '.prototype.';
                		}

                		if ([Number, String, Boolean].indexOf(obj.constructor) === -1) {
                			var betterPrefix = this.getPrefix(obj);
                			if (betterPrefix) {
                				this.orignalPrefix = betterPrefix + &quot;.&quot;;
                			}
                		}

                	}

                	if (!this.prefix) {

                		this.prefix = this.getPrefix(obj);

                		// 如果是类或对象， 在这里遍历。
                		if (this.prefix) {
                			this.title = this.prefix
                                    + (this.isClass ? this.getBaseClassDescription(obj) : ' ' + getMemberType(obj, this.memberName)) + &quot;的成员: &quot;;
                			this.prefix += '.';
                		}

                	}

                	// 如果是类，获取全部成员。
                	if (this.isClass) {
                		this.getExtInfo(obj);
                		this.addStaticMembers(obj);
                		this.addStaticMembers(obj.prototype, 1, true);
                		this.addEvents(obj, '');
                		delete this.members.prototype;
                		if (this.showPredefinedMembers) {
                			this.addPredefinedNonStaticMembers(obj, obj.prototype, true);
                			this.addPredefinedMembers(obj, obj, predefinedStatic);
                		}

                	} else {
                		this.getExtInfo(obj.constructor);
                		// 否则，获取当前实例下的成员。
                		this.addStaticMembers(obj);

                		if (this.showPredefinedMembers &amp;&amp; obj.constructor) {
                			this.addPredefinedNonStaticMembers(obj.constructor, obj);
                		}

                	}
                };

			APIInfo.prototype = {

				memberName: '',

				title: 'API 信息:',

				prefix: '',

				getPrefix: function (obj) {
					if (!obj)
						return &quot;&quot;;
					for (var i = 0; i &lt; definedClazz.length; i++) {
						if (window[definedClazz[i]] === obj) {
							return this.memberName = definedClazz[i];
						}
					}

					return this.getTypeName(obj, window, &quot;&quot;, 3);
				},

				getTypeName: function (obj, base, baseName, deep) {

					for (var memberName in base) {
						if (base[memberName] === obj) {
							this.memberName = memberName;
							return baseName + memberName;
						}
					}

					if (deep-- &gt; 0) {
						for (var memberName in base) {
							try {
								if (base[memberName] &amp;&amp; isUpper(memberName, 0)) {
									memberName = this.getTypeName(obj, base[memberName], baseName + memberName + &quot;.&quot;, deep);
									if (memberName)
										return memberName;
								}
							} catch (e) {
							}
						}
					}

					return '';
				},

				getBaseClassDescription: function (obj) {
					if (obj &amp;&amp; obj.base &amp;&amp; obj.base !== JPlus.Object) {
						var extObj = this.getTypeName(obj.base, window, &quot;&quot;, 3);
						return &quot; 类&quot; + (extObj &amp;&amp; extObj != &quot;System.Object&quot; ? &quot;(继承于 &quot; + extObj + &quot; 类)&quot; : &quot;&quot;);
					}

					return &quot; 类&quot;;
				},

				<span id="trace-getExtInfo">/**
                 * 获取类的继承关系。
                 */</span>
				getExtInfo: function (clazz) {
					if (!this.baseClasses) {
						this.baseClassNames = [];
						this.baseClasses = [];
						while (clazz &amp;&amp; clazz.prototype) {
							var name = this.getPrefix(clazz);
							if (name) {
								this.baseClasses.push(clazz);
								this.baseClassNames.push(name);
							}

							clazz = clazz.base;
						}
					}

				},

				addStaticMembers: function (obj, nonStatic) {
					for (var memberName in obj) {
						this.addMember(obj, memberName, 1, nonStatic);
					}

				},

				addPredefinedMembers: function (clazz, obj, staticOrNonStatic, nonStatic) {
					for (var type in staticOrNonStatic) {
						if (clazz === window[type]) {
							staticOrNonStatic[type].forEach(function (memberName) {
								this.addMember(obj, memberName, 5, nonStatic);
							}, this);
						}
					}
				},

				addPredefinedNonStaticMembers: function (clazz, obj, nonStatic) {

					if (clazz !== Object) {

						predefinedNonStatic.Object.forEach(function (memberName) {
							if (clazz.prototype[memberName] !== Object.prototype[memberName]) {
								this.addMember(obj, memberName, 5, nonStatic);
							}
						}, this);

					}

					if (clazz === Object &amp;&amp; !this.isClass) {
						return;
					}

					this.addPredefinedMembers(clazz, obj, predefinedNonStatic, nonStatic);

				},

				addEvents: function (obj, extInfo) {
					var evtInfo = obj.$event;

					if (evtInfo) {

						for (var evt in evtInfo) {
							this.sortInfo[this.members[evt] = evt + ' 事件' + extInfo] = 4 + evt;
						}

						if (obj.base) {
							this.addEvents(obj.base, '(继承的)');
						}
					}
				},

				addMember: function (base, memberName, type, nonStatic) {
					try {

						var hasOwnProperty = Object.prototype.hasOwnProperty, owner = hasOwnProperty.call(base, memberName), prefix, extInfo = '';

						nonStatic = nonStatic ? 'prototype.' : '';

						// 如果 base 不存在 memberName 的成员，则尝试在父类查找。
						if (owner) {
							prefix = this.orignalPrefix || (this.prefix + nonStatic);
							type--; // 自己的成员置顶。
						} else {

							// 搜索包含当前成员的父类。
							this.baseClasses.each(function (baseClass, i) {
								if (baseClass.prototype[memberName] === base[memberName] &amp;&amp; hasOwnProperty.call(baseClass.prototype, memberName)) {
									prefix = this.baseClassNames[i] + &quot;.prototype.&quot;;

									if (nonStatic)
										extInfo = '(继承的)';

									return false;
								}
							}, this);

							// 如果没找到正确的父类，使用当前类替代，并指明它是继承的成员。
							if (!prefix) {
								prefix = this.prefix + nonStatic;
								extInfo = '(继承的)';
							}

						}

						this.sortInfo[this.members[memberName] = (type &gt;= 4 ? '[内置]' : '') + prefix + getDescription(base, memberName) + extInfo] = type
							+ memberName;

					} catch (e) {
					}
				},

				copyTo: function (value) {
					for (var member in this.members) {
						value.push(this.members[member]);
					}

					if (value.length) {
						var sortInfo = this.sortInfo;
						value.sort(function (a, b) {
							return sortInfo[a] &lt; sortInfo[b] ? -1 : 1;
						});
						value.unshift(this.title);
					} else {
						value.push(this.title + '没有可用的子成员信息。');
					}

				}

			};

			initPredefined(predefinedNonStatic);
			initPredefined(predefinedStatic);

			function initPredefined(predefined) {
				for (var obj in predefined)
					predefined[obj] = predefined[obj].split(' ');
			}

			function isEmptyObject(obj) {

				// null 被认为是空对象。
				// 有成员的对象将进入 for(in) 并返回 false 。
				for (obj in (obj || {}))
					return false;
				return true;
			}

			// 90 是 'Z' 65 是 'A'
			function isUpper(str, index) {
				str = str.charCodeAt(index);
				return str &lt;= 90 &amp;&amp; str &gt;= 65;
			}

			function getMemberType(obj, name) {

				// 构造函数最好识别。
				if (typeof obj === 'function' &amp;&amp; name === 'constructor')
					return '构造函数';

				// IE6 的 DOM 成员不被认为是函数，这里忽略这个错误。
				// 有 prototype 的函数一定是类。
				// 没有 prototype 的函数肯能是类。
				// 这里根据命名如果名字首字母大写，则作为空类理解。
				// 这不是一个完全正确的判断方式，但它大部分时候正确。
				// 这个世界不要求很完美，能解决实际问题的就是好方法。
				if (obj.prototype &amp;&amp; obj.prototype.constructor)
					return !isEmptyObject(obj.prototype) || isUpper(name, 0) ? '类' : '函数';

				// 最后判断对象。
				if (obj &amp;&amp; typeof obj === 'object')
					return name.charAt(0) === 'I' &amp;&amp; isUpper(name, 1) ? '接口' : '对象';

				// 空成员、值类型都作为属性。
				return '属性';
			}

			function getDescription(base, name) {
				return name + ' ' + getMemberType(base[name], name);
			}

			return function (obj, showPredefinedMembers) {
				var r = [];

				// 如果没有参数，显示全局对象。
				if (arguments.length === 0) {
					for (var i = 0; i &lt; 7; i++) {
						r.push(getDescription(window, definedClazz[i]));
					}

					r.push(&quot;trace 函数&quot;, &quot;assert 函数&quot;, &quot;using 函数&quot;, &quot;imports 函数&quot;);

					for (var name in window) {

						try {
							if (isUpper(name, 0) || JPlus[name] === window[name])
								r.push(getDescription(window, name));
						} catch (e) {

						}
					}

					r.sort();
					r.unshift('全局对象: ');

				} else if (obj != null) {
					new APIInfo(obj, showPredefinedMembers).copyTo(r);
				} else {
					r.push('无法对 ' + (obj === null ? &quot;null&quot; : &quot;undefined&quot;) + ' 分析');
				}

				trace(r.join('\r\n'));

			};

		})(),

		<span id="trace-inspect">/**
         * 获取对象的字符串形式。
         * @param {Object} obj 要输出的内容。
         * @param {Number/undefined} deep=0 递归的层数。
         * @return String 成员。
         */</span>
		inspect: function (obj, deep, showArrayPlain) {

			if (deep == null)
				deep = 3;
			switch (typeof obj) {
				case &quot;function&quot;:
					// 函数
					return deep &gt;= 3 ? trace.decodeUTF8(obj.toString()) : &quot;function ()&quot;;

				case &quot;object&quot;:
					if (obj == null)
						return &quot;null&quot;;
					if (deep &lt; 0)
						return obj.toString();

					if (typeof obj.length === &quot;number&quot;) {
						var r = [];
						for (var i = 0; i &lt; obj.length; i++) {
							r.push(trace.inspect(obj[i], ++deep));
						}
						return showArrayPlain ? r.join(&quot;   &quot;) : (&quot;[&quot; + r.join(&quot;, &quot;) + &quot;]&quot;);
					} else {
						if (obj.setInterval &amp;&amp; obj.resizeTo)
							return &quot;window#&quot; + obj.document.URL;
						if (obj.nodeType) {
							if (obj.nodeType == 9)
								return 'document ' + obj.URL;
							if (obj.tagName) {
								var tagName = obj.tagName.toLowerCase(), r = tagName;
								if (obj.id) {
									r += &quot;#&quot; + obj.id;
									if (obj.className)
										r += &quot;.&quot; + obj.className;
								} else if (obj.outerHTML)
									r = obj.outerHTML;
								else {
									if (obj.className)
										r += &quot; class=\&quot;.&quot; + obj.className + &quot;\&quot;&quot;;
									r = &quot;&lt;&quot; + r + &quot;&gt;&quot; + obj.innerHTML + &quot;&lt;/&quot; + tagName + &quot;&gt;  &quot;;
								}

								return r;
							}

							return '[Node type=' + obj.nodeType +' name=' + obj.nodeName + ' value=' + obj.nodeValue + ']';
						}
						var r = &quot;{\r\n&quot;, i, flag = 0;
						for (i in obj) {
							if (typeof obj[i] !== 'function')
								r += &quot;\t&quot; + i + &quot; = &quot; + trace.inspect(obj[i], deep - 1) + &quot;\r\n&quot;;
							else {
								flag++;
							}
						}

						if (flag) {
							r += '\t... (' + flag + '个函数)\r\n';
						}

						r += &quot;}&quot;;
						return r;
					}
				case &quot;string&quot;:
					return deep &gt;= 3 ? obj : '&quot;' + obj + '&quot;';
				case &quot;undefined&quot;:
					return &quot;undefined&quot;;
				default:
					return obj.toString();
			}
		},

		<span id="trace-log">/**
         * 输出方式。 {@param {String} message 信息。}
         * @type Function
         */</span>
		log: function (message) {
			if (trace.enable &amp;&amp; window.console &amp;&amp; console.log) {
				window.console.log(message);
			}
		},

		<span id="trace-error">/**
         * 输出一个错误信息。
         * @param {Object} msg 内容。
         */</span>
		error: function (msg) {
			if (trace.enable) {
				if (window.console &amp;&amp; console.error)
					window.console.error(msg); // 这是一个预知的错误，请根据函数调用堆栈查找错误原因。
				else
					throw msg; // 这是一个预知的错误，请根据函数调用堆栈查找错误原因。
			}
		},

		<span id="trace-warn">/**
         * 输出一个警告信息。
         * @param {Object} msg 内容。
         */</span>
		warn: function (msg) {
			if (trace.enable) {
				if (window.console &amp;&amp; console.warn)
					window.console.warn(msg);
				else
					window.trace(&quot;[警告]&quot; + msg);
			}
		},

		<span id="trace-info">/**
         * 输出一个信息。
         * @param {Object} msg 内容。
         */</span>
		info: function (msg) {
			if (trace.enable) {
				if (window.console &amp;&amp; console.info)
					window.console.info(msg);
				else
					window.trace.write(&quot;[信息]&quot; + msg);
			}
		},

		<span id="trace-dir">/**
         * 遍历对象每个元素。
         * @param {Object} obj 对象。
         */</span>
		dir: function (obj) {
			if (trace.enable) {
				if (window.console &amp;&amp; console.dir)
					window.console.dir(obj);
				else if (obj) {
					var r = &quot;&quot;, i;
					for (i in obj)
						r += i + &quot; = &quot; + trace.inspect(obj[i], 1) + &quot;\r\n&quot;;
					window.trace(r);
				}
			}
		},

		<span id="trace-clear">/**
         * 清除调试信息。 (没有控制台时，不起任何作用)
         */</span>
		clear: function () {
			if (window.console &amp;&amp; console.clear)
				window.console.clear();
		},

		<span id="trace-eval">/**
         * 如果是调试模式就运行。
         * @param {String/Function} code 代码。
         * @return String 返回运行的错误。如无错, 返回空字符。
         */</span>
		eval: function (code) {
			if (trace.enable) {
				try {
					typeof code === 'function' ? code() : eval(code);
				} catch (e) {
					return e;
				}
			}
			return &quot;&quot;;
		},

		<span id="trace-time">/**
         * 输出一个函数执行指定次使用的时间。
         * @param {Function} fn 函数。
         */</span>
		time: function (fn) {
			var time = 0,
				currentTime,
				start = +new Date(),
				past;

			try {

				do {

					time += 10;

					currentTime = 10;
					while (--currentTime &gt; 0) {
						fn();
					}

					past = +new Date() - start;

				} while (past &lt; 100);

			} catch (e) {

			}
			window.trace(&quot;[时间] &quot; + past / time);
		}

	});

	/// #region Assert

	/**
     * @namespace assert
     */
	extend(assert, {

		<span id="assert-stackTrace">/**
		 * 是否在 assert 失败时显示函数调用堆栈。
		 * @config {Boolean} stackTrace
		 */</span>
		stackTrace: true,
		
		debugStepThrough: true,
		
		<span id="assert-deprected">/**
		 * 指示一个函数已过时。
		 * @param {String} message=&quot;此成员已过时&quot; 提示的信息。
		 */</span>
		deprected: function(message) {
			trace.warn(message || &quot;此成员已过时&quot;);
		},

		<span id="assert-isFunction">/**
         * 确认一个值为函数。
		 * @param {Object} value 要用于判断的值。它会被自动转为布尔型之后再作判断。
		 * @param {String} message=&quot;断言失败&quot; 如果 *value* 为 **false**, 则显示的错误提示。可以用 ~ 代替默认的错误提示信息。
		 * @return {Boolean} 返回 *value* 的等效布尔值。
         * @example &lt;pre&gt;
         * assert.isFunction(a, &quot;a ~&quot;);
         * &lt;/pre&gt;
         */</span>
		isFunction: createAssertFunc(function (value) {
			return typeof value == 'function';
		}, &quot;必须是函数。&quot;),

		<span id="assert-isArray">/**
         * 确认一个值为数组。
		 * @param {Object} value 要用于判断的值。它会被自动转为布尔型之后再作判断。
		 * @param {String} message=&quot;断言失败&quot; 如果 *value* 为 **false**, 则显示的错误提示。可以用 ~ 代替默认的错误提示信息。
		 * @return {Boolean} 返回 *value* 的等效布尔值。
         */</span>
		isArray: createAssertFunc(function (value) {
			return typeof value.length == 'number';
		}, &quot;必须是数组。&quot;),

		<span id="assert-isNumber">/**
         * 确认一个值为数字。
		 * @param {Object} value 要用于判断的值。它会被自动转为布尔型之后再作判断。
		 * @param {String} message=&quot;断言失败&quot; 如果 *value* 为 **false**, 则显示的错误提示。可以用 ~ 代替默认的错误提示信息。
		 * @return {Boolean} 返回 *value* 的等效布尔值。
         */</span>
		isNumber: createAssertFunc(function (value) {
			return typeof value === &quot;number&quot; || value instanceof Number;
		}, &quot;必须是数字。&quot;),

		<span id="assert-isString">/**
         * 确认一个值是字符串。
		 * @param {Object} value 要用于判断的值。它会被自动转为布尔型之后再作判断。
		 * @param {String} message=&quot;断言失败&quot; 如果 *value* 为 **false**, 则显示的错误提示。可以用 ~ 代替默认的错误提示信息。
		 * @return {Boolean} 返回 *value* 的等效布尔值。
         */</span>
		isString: createAssertFunc(function (value) {
			return typeof value === &quot;string&quot; || value instanceof String;
		}, &quot;必须是字符串。&quot;),

		<span id="assert-isDate">/**
         * 确认一个值是日期。
		 * @param {Object} value 要用于判断的值。它会被自动转为布尔型之后再作判断。
		 * @param {String} message=&quot;断言失败&quot; 如果 *value* 为 **false**, 则显示的错误提示。可以用 ~ 代替默认的错误提示信息。
		 * @return {Boolean} 返回 *value* 的等效布尔值。
         */</span>
		isDate: createAssertFunc(function (value) {
			return value &amp;&amp; value instanceof Date;
		}, &quot;必须是日期对象。&quot;),

		<span id="assert-isRegExp">/**
         * 确认一个值是正则表达式。
		 * @param {Object} value 要用于判断的值。它会被自动转为布尔型之后再作判断。
		 * @param {String} message=&quot;断言失败&quot; 如果 *value* 为 **false**, 则显示的错误提示。可以用 ~ 代替默认的错误提示信息。
		 * @return {Boolean} 返回 *value* 的等效布尔值。
         */</span>
		isRegExp: createAssertFunc(function (value) {
			return value &amp;&amp; value instanceof RegExp;
		}, &quot;必须是正则表达式。&quot;),

		<span id="assert-isObject">/**
         * 确认一个值为函数变量。
		 * @param {Object} value 要用于判断的值。它会被自动转为布尔型之后再作判断。
		 * @param {String} message=&quot;断言失败&quot; 如果 *value* 为 **false**, 则显示的错误提示。可以用 ~ 代替默认的错误提示信息。
		 * @return {Boolean} 返回 *value* 的等效布尔值。
         */</span>
		isObject: createAssertFunc(function (value) {
			return value &amp;&amp; (typeof value === &quot;object&quot; || typeof value === &quot;function&quot; || typeof value.nodeType === &quot;number&quot;);
		}, &quot;必须是一个引用对象。&quot;),

		<span id="assert-isNode">/**
         * 确认一个值为节点。
		 * @param {Object} value 要用于判断的值。它会被自动转为布尔型之后再作判断。
		 * @param {String} message=&quot;断言失败&quot; 如果 *value* 为 **false**, 则显示的错误提示。可以用 ~ 代替默认的错误提示信息。
		 * @return {Boolean} 返回 *value* 的等效布尔值。
         */</span>
		isNode: createAssertFunc(function (value) {
			return value ? typeof value.nodeType === &quot;number&quot; || value.setTimeout : value === null;
		}, &quot;必须是 DOM 节点。&quot;),

		<span id="assert-isElement">/**
         * 确认一个值为节点。
		 * @param {Object} value 要用于判断的值。它会被自动转为布尔型之后再作判断。
		 * @param {String} message=&quot;断言失败&quot; 如果 *value* 为 **false**, 则显示的错误提示。可以用 ~ 代替默认的错误提示信息。
		 * @return {Boolean} 返回 *value* 的等效布尔值。
         */</span>
		isElement: createAssertFunc(function (value) {
			return value ? typeof value.nodeType === &quot;number&quot; &amp;&amp; value.style : value === null;
		}, &quot;必须是 DOM 元素。&quot;),

		<span id="assert-notNull">/**
         * 确认一个值非空。
		 * @param {Object} value 要用于判断的值。它会被自动转为布尔型之后再作判断。
		 * @param {String} message=&quot;断言失败&quot; 如果 *value* 为 **false**, 则显示的错误提示。可以用 ~ 代替默认的错误提示信息。
		 * @return {Boolean} 返回 *value* 的等效布尔值。
         */</span>
		notNull: createAssertFunc(function (value) {
			return value != null;
		}, &quot;不可为空。&quot;)

	});

	function createAssertFunc(assertFunction, defaultMessage) {
		var fn = function (value, message) {
			return assert(assertFunction(value), (message || &quot;断言失败。&quot;).replace('~', defaultMessage), value)
		};
		fn.debugStepThrough = true;
		return fn;
	}

	/// #endregion

	/// #region Using

	extend(using, {

		<span id="assert-loadScript">/**
         * 同步载入代码。
         * @param {String} uri 地址。
         * @example &lt;pre&gt;
         * JPlus.loadScript('./v.js');
         * &lt;/pre&gt;
         */</span>
	    loadScript: function (url) {

	        var src = using.loadText(url);

	        if(src){
	            try {
	                if(window.execScript) {
	                    window.execScript(src);
	                } else {
	                    window[&quot;eval&quot;].call(window, src);
	                }
	            } catch (e) {
	                trace.error(&quot;执行 &quot; + url + &quot; 出现错误: &quot; + e.toString());
	            } 
	        }
		},

		<span id="assert-loadStyle">/**
         * 异步载入样式。
         * @param {String} uri 地址。
         * @example &lt;pre&gt;
         * JPlus.loadStyle('./v.css');
         * &lt;/pre&gt;
         */</span>
		loadStyle: function (url) {

			// 在顶部插入一个css，但这样肯能导致css没加载就执行 js 。所以，要保证样式加载后才能继续执行计算。
			return document.getElementsByTagName(&quot;HEAD&quot;)[0].appendChild(extend(document.createElement('link'), {
				href: url,
				rel: 'stylesheet',
				type: 'text/css'
			}));
		},

		<span id="assert-loadText">/**
         * 同步载入文本。
         * @param {String} uri 地址。
         * @param {Function} [callback] 对返回值的处理函数。
         * @return {String} 载入的值。 因为同步，所以无法跨站。
         * @example &lt;pre&gt;
         * trace(  JPlus.loadText('./v.html')  );
         * &lt;/pre&gt;
         */</span>
		loadText: function (url) {

			// 新建请求。
			// 下文对 XMLHttpRequest 对象进行兼容处理。
		    var xmlHttp = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;),
		        status;

			try {

				// 打开请求。
				xmlHttp.open(&quot;GET&quot;, url, false);

				// 发送请求。
				xmlHttp.send(null);

                // 获取返回的状态码。
				status = xmlHttp.status;

                // 判断状态码是否合格。
				if ((status &gt;= 200 &amp;&amp; status &lt; 300) || status == 304 || status == 1223) {
				    // 返回相应内容。
				    return xmlHttp.responseText;
				} else {
				    throw &quot;服务器返回状态码 &quot; + status;
				}

			} catch (e) {

			    // 调试输出。
			    trace.error(&quot;请求失败: &quot; + url + &quot; \r\n\t原因: &quot; + (window.location.protocol == &quot;file:&quot; ? &quot; 本网页是使用 file 协议打开的，请改用 http 协议。&quot; : e.toString()));

			} finally {

				// 释放资源。
				xmlHttp = null;
			}

		},

		<span id="assert-styles">/**
         * 全部已载入的样式。
         * @type Array
         * @private
         */</span>
		styles: [],

		<span id="assert-scripts">/**
         * 全部已载入的组件全名。
         * @type Array
         * @private
         */</span>
		scripts: [],

		<span id="assert-rootPath">/**
         * JPlus 安装的根目录, 可以为相对目录。
         * @config {String}
         */</span>
		rootPath: (function () {
			try {
				var scripts = document.getElementsByTagName(&quot;script&quot;);

				// 当前脚本在 &lt;script&gt; 引用。最后一个脚本即当前执行的文件。
				scripts = scripts[scripts.length - 1];

				// IE6/7 使用 getAttribute
				scripts = !document.constructor ? scripts.getAttribute('src', 4) : scripts.src;

				// 设置路径。
				return (scripts.match(/([\S\s]*\/)System\/Core\/assets\/scripts\//) || [0, &quot;&quot;])[1];

			} catch (e) {

				// 出错后，设置当前位置.
				return &quot;&quot;;
			}

		})(),

		<span id="assert-resolve">/**
         * 将指定的组件全名转为路径。
         * @param {String} namespace 组件全名。
         * @param {Boolean} isStyle=false 是否为样式表。
         */</span>
		resolve: function (namespace, isStyle) {
			return namespace.replace(/^([^.]+\.[^.]+)\./, isStyle ? '$1.assets.styles.' : '$1.assets.scripts.').replace(/\./g, '/');
		}

	});

	/// #endregion

	/// #endregion

	/**
	 * 复制所有属性到任何对象。
	 * @param {Object} dest 复制目标。
	 * @param {Object} src 要复制的内容。
	 * @return {Object} 复制后的对象。
	 */
	function extend(dest, src) {

		assert(dest != null, &quot;Object.extend(dest, src): {dest} 不可为空。&quot;, dest);

		// 直接遍历，不判断是否为真实成员还是原型的成员。
		for (var b in src)
			dest[b] = src[b];
		return dest;
	}

})();

/// #endif
</pre>
</body>
</html>
