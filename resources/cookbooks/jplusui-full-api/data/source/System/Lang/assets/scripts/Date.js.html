<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>System\Lang\assets\scripts\Date.js 源码</title>
		<link href="../../assets/styles/prettify.css" type="text/css" rel="stylesheet" />
		<script src="../../assets/scripts/prettify.js" type="text/javascript"></script>
		<style type="text/css">.highlight { display: block; background-color: #ddd; }</style>
</head>
<body onload="setTimeout('prettyPrint()', 0);var node = document.getElementById(location.hash.replace(/#/, ''));if(node)node.className = 'highlight';"><pre class="prettyprint lang-js">//===========================================
//  日期扩展       
//===========================================






Date.implement({

	getTimezone: function(){
		return this.toString()
			.replace(/^.*? ([A-Z]{3}).[0-9]{4}.*$/, '$1')
			.replace(/^.*?\(([A-Z])[a-z]+ ([A-Z])[a-z]+ ([A-Z])[a-z]+\)$/, '$1$2$3');
	},
	
	getGMTOffset: function() {
	    return (this.getTimezoneOffset() &gt; 0 ? &quot;-&quot; : &quot;+&quot;)
	        + String.leftPad(Math.floor(this.getTimezoneOffset() / 60), 2, &quot;0&quot;)
	        + String.leftPad(this.getTimezoneOffset() % 60, 2, &quot;0&quot;);
	},
	
	getFirstDay: function() {
	    var day = (this.getDay() - (this.getDate() - 1)) % 7;
	    return (day &lt; 0) ? (day + 7) : day;
	},
	
	
	getLastDay: function() {
	    var day = (this.getDay() + (Date.daysInMonth[this.getMonth()] - this.getDate())) % 7;
	    return (day &lt; 0) ? (day + 7) : day;
	},

	isPM: function(){
		return (this.get('hr') &gt;= 12);
	},
	
	clearTime: function(){
	    this.setHours(0);
	    this.setMinutes(0);
	    this.setSeconds(0);
	    this.setMilliseconds(0);
	},
	
	<span id="clearDay">/**
	 * 转到本月第一天。
	 */</span>
	clearDay: function(){
		
	},
	
	

	setPM: function(value){
		var hr = this.get('hr');
		if (hr &gt; 11 &amp;&amp; ampm == 'AM') return this.decrement('hour', 12);
		else if (hr &lt; 12 &amp;&amp; ampm == 'PM') return this.increment('hour', 12);
		return this;
	},
	
	toISOString: function(){
		
	}
});


Object.extend(Date, {
	
	parse: function(str, format){
		
	},
	
	getDayInYear: function(year) {
	    var num = 0;
	    Date.daysInMonth[1] = this.isLeapYear() ? 29 : 28;
	    for (var i = 0; i &lt; this.getMonth(); ++i) {
	        num += Date.daysInMonth[i];
	    }
	    return num + this.getDate() - 1;
	},
	
	getWeekOfYear: function(year, day) {
	    
	    var now = this.getDayOfYear() + (4 - this.getDay());
	    
	    var jan1 = new Date(this.getFullYear(), 0, 1);
	    var then = (7 - jan1.getDay() + 4);
	    return ((now - then) / 7) + 1;
	},

    <span id="isValid">/**
     * Checks if the passed Date parameters will cause a javascript Date &quot;rollover&quot;.
     * @param {Number} year 4-digit year
     * @param {Number} month 1-based month-of-year
     * @param {Number} day Day of month
     * @param {Number} hour (optional) Hour
     * @param {Number} minute (optional) Minute
     * @param {Number} second (optional) Second
     * @param {Number} millisecond (optional) Millisecond
     * @return {Boolean} true if the passed parameters do not cause a Date &quot;rollover&quot;, false otherwise.
     * @static
     */</span>
    isValid : function(y, m, d, h, i, s, ms) {
        // setup defaults
        h = h || 0;
        i = i || 0;
        s = s || 0;
        ms = ms || 0;

        // Special handling for year &lt; 100
        var dt = utilDate.add(new Date(y &lt; 100 ? 100 : y, m - 1, d, h, i, s, ms), utilDate.YEAR, y &lt; 100 ? y - 100 : 0);

        return y == dt.getFullYear() &amp;&amp;
            m == dt.getMonth() + 1 &amp;&amp;
            d == dt.getDate() &amp;&amp;
            h == dt.getHours() &amp;&amp;
            i == dt.getMinutes() &amp;&amp;
            s == dt.getSeconds() &amp;&amp;
            ms == dt.getMilliseconds();
    },
	

    <span id="isDST">/**
     * Checks if the current date is affected by Daylight Saving Time (DST).
     * @param {Date} date The date
     * @return {Boolean} True if the current date is affected by DST.
     */</span>
    isDST : function(date) {
        // adapted from http://sencha.com/forum/showthread.php?p=247172#post247172
        // courtesy of @geoffrey.mcgill
        return new Date(date.getFullYear(), 0, 1).getTimezoneOffset() != date.getTimezoneOffset();
    },
	
    <span id="between">/**
     * Checks if a date falls on or between the given start and end dates.
     * @param {Date} date The date to check
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Boolean} true if this date falls on or between the given start and end dates.
     */</span>
    between : function(date, start, end) {
        var t = date.getTime();
        return start.getTime() &lt;= t &amp;&amp; t &lt;= end.getTime();
    },

});
	
/*
Date.parseFunctions = {count:0};

Date.parseRegexes = [];

Date.formatFunctions = {count:0};




Date.getFormatCode = function(character) {
    switch (character) {
    case &quot;d&quot;:
        return &quot;String.leftPad(this.getDate(), 2, '0') + &quot;;
    case &quot;D&quot;:
        return &quot;Date.dayNames[this.getDay()].substring(0, 3) + &quot;;
    case &quot;j&quot;:
        return &quot;this.getDate() + &quot;;
    case &quot;l&quot;:
        return &quot;Date.dayNames[this.getDay()] + &quot;;
    case &quot;S&quot;:
        return &quot;this.getSuffix() + &quot;;
    case &quot;w&quot;:
        return &quot;this.getDay() + &quot;;
    case &quot;z&quot;:
        return &quot;this.getDayOfYear() + &quot;;
    case &quot;W&quot;:
        return &quot;this.getWeekOfYear() + &quot;;
    case &quot;F&quot;:
        return &quot;Date.monthNames[this.getMonth()] + &quot;;
    case &quot;m&quot;:
        return &quot;String.leftPad(this.getMonth() + 1, 2, '0') + &quot;;
    case &quot;M&quot;:
        return &quot;Date.monthNames[this.getMonth()].substring(0, 3) + &quot;;
    case &quot;n&quot;:
        return &quot;(this.getMonth() + 1) + &quot;;
    case &quot;t&quot;:
        return &quot;this.getDaysInMonth() + &quot;;
    case &quot;L&quot;:
        return &quot;(this.isLeapYear() ? 1 : 0) + &quot;;
    case &quot;Y&quot;:
        return &quot;this.getFullYear() + &quot;;
    case &quot;y&quot;:
        return &quot;('' + this.getFullYear()).substring(2, 4) + &quot;;
    case &quot;a&quot;:
        return &quot;(this.getHours() &lt; 12 ? 'am' : 'pm') + &quot;;
    case &quot;A&quot;:
        return &quot;(this.getHours() &lt; 12 ? 'AM' : 'PM') + &quot;;
    case &quot;g&quot;:
        return &quot;((this.getHours() %12) ? this.getHours() % 12 : 12) + &quot;;
    case &quot;G&quot;:
        return &quot;this.getHours() + &quot;;
    case &quot;h&quot;:
        return &quot;String.leftPad((this.getHours() %12) ? this.getHours() % 12 : 12, 2, '0') + &quot;;
    case &quot;H&quot;:
        return &quot;String.leftPad(this.getHours(), 2, '0') + &quot;;
    case &quot;i&quot;:
        return &quot;String.leftPad(this.getMinutes(), 2, '0') + &quot;;
    case &quot;s&quot;:
        return &quot;String.leftPad(this.getSeconds(), 2, '0') + &quot;;
    case &quot;O&quot;:
        return &quot;this.getGMTOffset() + &quot;;
    case &quot;T&quot;:
        return &quot;this.getTimezone() + &quot;;
    case &quot;Z&quot;:
        return &quot;(this.getTimezoneOffset() * -60) + &quot;;
    default:
        return &quot;'&quot; + String.escape(character) + &quot;' + &quot;;
    }
};


Date.parseDate = function(input, format) {
    if (Date.parseFunctions[format] == null) {
        Date.createParser(format);
    }
    var func = Date.parseFunctions[format];
    return Date[func](input);
};


Date.createParser = function(format) {
    var funcName = &quot;parse&quot; + Date.parseFunctions.count++;
    var regexNum = Date.parseRegexes.length;
    var currentGroup = 1;
    Date.parseFunctions[format] = funcName;

    var code = &quot;Date.&quot; + funcName + &quot; = function(input){\n&quot;
        + &quot;var y = -1, m = -1, d = -1, h = -1, i = -1, s = -1;\n&quot;
        + &quot;var d = new Date();\n&quot;
        + &quot;y = d.getFullYear();\n&quot;
        + &quot;m = d.getMonth();\n&quot;
        + &quot;d = d.getDate();\n&quot;
        + &quot;var results = input.match(Date.parseRegexes[&quot; + regexNum + &quot;]);\n&quot;
        + &quot;if (results &amp;&amp; results.length &gt; 0) {&quot;;
    var regex = &quot;&quot;;

    var special = false;
    var ch = '';
    for (var i = 0; i &lt; format.length; ++i) {
        ch = format.charAt(i);
        if (!special &amp;&amp; ch == &quot;\\&quot;) {
            special = true;
        }
        else if (special) {
            special = false;
            regex += String.escape(ch);
        }
        else {
            var obj = Date.formatCodeToRegex(ch, currentGroup);
            currentGroup += obj.g;
            regex += obj.s;
            if (obj.g &amp;&amp; obj.c) {
                code += obj.c;
            }
        }
    }

    code += &quot;if (y &gt; 0 &amp;&amp; m &gt;= 0 &amp;&amp; d &gt; 0 &amp;&amp; h &gt;= 0 &amp;&amp; i &gt;= 0 &amp;&amp; s &gt;= 0)\n&quot;
        + &quot;{return new Date(y, m, d, h, i, s);}\n&quot;
        + &quot;else if (y &gt; 0 &amp;&amp; m &gt;= 0 &amp;&amp; d &gt; 0 &amp;&amp; h &gt;= 0 &amp;&amp; i &gt;= 0)\n&quot;
        + &quot;{return new Date(y, m, d, h, i);}\n&quot;
        + &quot;else if (y &gt; 0 &amp;&amp; m &gt;= 0 &amp;&amp; d &gt; 0 &amp;&amp; h &gt;= 0)\n&quot;
        + &quot;{return new Date(y, m, d, h);}\n&quot;
        + &quot;else if (y &gt; 0 &amp;&amp; m &gt;= 0 &amp;&amp; d &gt; 0)\n&quot;
        + &quot;{return new Date(y, m, d);}\n&quot;
        + &quot;else if (y &gt; 0 &amp;&amp; m &gt;= 0)\n&quot;
        + &quot;{return new Date(y, m);}\n&quot;
        + &quot;else if (y &gt; 0)\n&quot;
        + &quot;{return new Date(y);}\n&quot;
        + &quot;}return null;}&quot;;

    Date.parseRegexes[regexNum] = new RegExp(&quot;^&quot; + regex + &quot;$&quot;);
    eval(code);
};


Date.formatCodeToRegex = function(character, currentGroup) {
    switch (character) {
    case &quot;D&quot;:
        return {g:0,
        c:null,
        s:&quot;(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)&quot;};
    case &quot;j&quot;:
    case &quot;d&quot;:
        return {g:1,
            c:&quot;d = parseInt(results[&quot; + currentGroup + &quot;], 10);\n&quot;,
            s:&quot;(\\d{1,2})&quot;};
    case &quot;l&quot;:
        return {g:0,
            c:null,
            s:&quot;(?:&quot; + Date.dayNames.join(&quot;|&quot;) + &quot;)&quot;};
    case &quot;S&quot;:
        return {g:0,
            c:null,
            s:&quot;(?:st|nd|rd|th)&quot;};
    case &quot;w&quot;:
        return {g:0,
            c:null,
            s:&quot;\\d&quot;};
    case &quot;z&quot;:
        return {g:0,
            c:null,
            s:&quot;(?:\\d{1,3})&quot;};
    case &quot;W&quot;:
        return {g:0,
            c:null,
            s:&quot;(?:\\d{2})&quot;};
    case &quot;F&quot;:
        return {g:1,
            c:&quot;m = parseInt(Date.monthNumbers[results[&quot; + currentGroup + &quot;].substring(0, 3)], 10);\n&quot;,
            s:&quot;(&quot; + Date.monthNames.join(&quot;|&quot;) + &quot;)&quot;};
    case &quot;M&quot;:
        return {g:1,
            c:&quot;m = parseInt(Date.monthNumbers[results[&quot; + currentGroup + &quot;]], 10);\n&quot;,
            s:&quot;(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)&quot;};
    case &quot;n&quot;:
    case &quot;m&quot;:
        return {g:1,
            c:&quot;m = parseInt(results[&quot; + currentGroup + &quot;], 10) - 1;\n&quot;,
            s:&quot;(\\d{1,2})&quot;};
    case &quot;t&quot;:
        return {g:0,
            c:null,
            s:&quot;\\d{1,2}&quot;};
    case &quot;L&quot;:
        return {g:0,
            c:null,
            s:&quot;(?:1|0)&quot;};
    case &quot;Y&quot;:
        return {g:1,
            c:&quot;y = parseInt(results[&quot; + currentGroup + &quot;], 10);\n&quot;,
            s:&quot;(\\d{4})&quot;};
    case &quot;y&quot;:
        return {g:1,
            c:&quot;var ty = parseInt(results[&quot; + currentGroup + &quot;], 10);\n&quot;
                + &quot;y = ty &gt; Date.y2kYear ? 1900 + ty : 2000 + ty;\n&quot;,
            s:&quot;(\\d{1,2})&quot;};
    case &quot;a&quot;:
        return {g:1,
            c:&quot;if (results[&quot; + currentGroup + &quot;] == 'am') {\n&quot;
                + &quot;if (h == 12) { h = 0; }\n&quot;
                + &quot;} else { if (h &lt; 12) { h += 12; }}&quot;,
            s:&quot;(am|pm)&quot;};
    case &quot;A&quot;:
        return {g:1,
            c:&quot;if (results[&quot; + currentGroup + &quot;] == 'AM') {\n&quot;
                + &quot;if (h == 12) { h = 0; }\n&quot;
                + &quot;} else { if (h &lt; 12) { h += 12; }}&quot;,
            s:&quot;(AM|PM)&quot;};
    case &quot;g&quot;:
    case &quot;G&quot;:
    case &quot;h&quot;:
    case &quot;H&quot;:
        return {g:1,
            c:&quot;h = parseInt(results[&quot; + currentGroup + &quot;], 10);\n&quot;,
            s:&quot;(\\d{1,2})&quot;};
    case &quot;i&quot;:
        return {g:1,
            c:&quot;i = parseInt(results[&quot; + currentGroup + &quot;], 10);\n&quot;,
            s:&quot;(\\d{2})&quot;};
    case &quot;s&quot;:
        return {g:1,
            c:&quot;s = parseInt(results[&quot; + currentGroup + &quot;], 10);\n&quot;,
            s:&quot;(\\d{2})&quot;};
    case &quot;O&quot;:
        return {g:0,
            c:null,
            s:&quot;[+-]\\d{4}&quot;};
    case &quot;T&quot;:
        return {g:0,
            c:null,
            s:&quot;[A-Z]{3}&quot;};
    case &quot;Z&quot;:
        return {g:0,
            c:null,
            s:&quot;[+-]\\d{1,5}&quot;};
    default:
        return {g:0,
            c:null,
            s:String.escape(character)};
    }
};
 
 

*/
 
  


/*
---

script: Date.js

name: Date

description: Extends the Date native object to include methods useful in managing dates.

license: MIT-style license

authors:
  - Aaron Newton
  - Nicholas Barthelemy - https://svn.nbarthelemy.com/date-js/
  - Harald Kirshner - mail [at] digitarald.de; http://digitarald.de
  - Scott Kyle - scott [at] appden.com; http://appden.com

requires:
  - Core/Array
  - Core/String
  - Core/Number
  - /Locale
  - /Locale.en-US.Date
  - /MooTools.More

provides: [Date]

...
*/

/*
format: function(f){
		if (!this.isValid()) return 'invalid date';
		f = f || '%x %X';
		f = formats[f.toLowerCase()] || f; // replace short-hand with actual format
		var d = this;
		return f.replace(/%([a-z%])/gi,
			function($0, $1){
				switch ($1){
					case 'a': return Date.getMsg('days_abbr')[d.get('day')];
					case 'A': return Date.getMsg('days')[d.get('day')];
					case 'b': return Date.getMsg('months_abbr')[d.get('month')];
					case 'B': return Date.getMsg('months')[d.get('month')];
					case 'c': return d.format('%a %b %d %H:%m:%S %Y');
					case 'd': return pad(d.get('date'), 2);
					case 'e': return pad(d.get('date'), 2, ' ');
					case 'H': return pad(d.get('hr'), 2);
					case 'I': return pad((d.get('hr') % 12) || 12, 2);
					case 'j': return pad(d.get('dayofyear'), 3);
					case 'k': return pad(d.get('hr'), 2, ' ');
					case 'l': return pad((d.get('hr') % 12) || 12, 2, ' ');
					case 'L': return pad(d.get('ms'), 3);
					case 'm': return pad((d.get('mo') + 1), 2);
					case 'M': return pad(d.get('min'), 2);
					case 'o': return d.get('ordinal');
					case 'p': return Date.getMsg(d.get('ampm'));
					case 's': return Math.round(d / 1000);
					case 'S': return pad(d.get('seconds'), 2);
					case 'U': return pad(d.get('week'), 2);
					case 'w': return d.get('day');
					case 'x': return d.format(Date.getMsg('shortDate'));
					case 'X': return d.format(Date.getMsg('shortTime'));
					case 'y': return d.get('year').toString().substr(2);
					case 'Y': return d.get('year');
					
					case 'z': return d.get('GMTOffset');
					case 'Z': return d.get('Timezone');
				}
				return $1;
			}
		);
	},
	
	
	
var formats = {
	db: '%Y-%m-%d %H:%M:%S',
	compact: '%Y%m%dT%H%M%S',
	iso8601: '%Y-%m-%dT%H:%M:%S%T',
	rfc822: '%a, %d %b %Y %H:%M:%S %Z',
	'short': '%d %b %H:%M',
	'long': '%B %d, %Y %H:%M'
};



var parsePatterns = [];
var nativeParse = Date.parse;

var parseWord = function(type, word, num){
	var ret = -1;
	var translated = Date.getMsg(type + 's');
	switch (typeOf(word)){
		case 'object':
			ret = translated[word.get(type)];
			break;
		case 'number':
			ret = translated[word];
			if (!ret) throw new Error('Invalid ' + type + ' index: ' + word);
			break;
		case 'string':
			var match = translated.filter(function(name){
				return this.test(name);
			}, new RegExp('^' + word, 'i'));
			if (!match.length) throw new Error('Invalid ' + type + ' string');
			if (match.length &gt; 1) throw new Error('Ambiguous ' + type);
			ret = match[0];
	}

	return (num) ? translated.indexOf(ret) : ret;
};






*/

 
	 
<span id="Ext-Date">/**
 * @class Ext.Date
 * A set of useful static methods to deal with date
 * Note that if Ext.Date is required and loaded, it will copy all methods / properties to
 * this object for convenience
 *
 * The date parsing and formatting syntax contains a subset of
 * &lt;a href=&quot;http://www.php.net/date&quot;&gt;PHP's date() function&lt;/a&gt;, and the formats that are
 * supported will provide results equivalent to their PHP versions.
 *
 * The following is a list of all currently supported formats:
 * &lt;pre class=&quot;&quot;&gt;
Format  Description                                                               Example returned values
------  -----------------------------------------------------------------------   -----------------------
  d     Day of the month, 2 digits with leading zeros                             01 to 31
  D     A short textual representation of the day of the week                     Mon to Sun
  j     Day of the month without leading zeros                                    1 to 31
  l     A full textual representation of the day of the week                      Sunday to Saturday
  N     ISO-8601 numeric representation of the day of the week                    1 (for Monday) through 7 (for Sunday)
  S     English ordinal suffix for the day of the month, 2 characters             st, nd, rd or th. Works well with j
  w     Numeric representation of the day of the week                             0 (for Sunday) to 6 (for Saturday)
  z     The day of the year (starting from 0)                                     0 to 364 (365 in leap years)
  W     ISO-8601 week number of year, weeks starting on Monday                    01 to 53
  F     A full textual representation of a month, such as January or March        January to December
  m     Numeric representation of a month, with leading zeros                     01 to 12
  M     A short textual representation of a month                                 Jan to Dec
  n     Numeric representation of a month, without leading zeros                  1 to 12
  t     Number of days in the given month                                         28 to 31
  L     Whether it&amp;#39;s a leap year                                                  1 if it is a leap year, 0 otherwise.
  o     ISO-8601 year number (identical to (Y), but if the ISO week number (W)    Examples: 1998 or 2004
        belongs to the previous or next year, that year is used instead)
  Y     A full numeric representation of a year, 4 digits                         Examples: 1999 or 2003
  y     A two digit representation of a year                                      Examples: 99 or 03
  a     Lowercase Ante meridiem and Post meridiem                                 am or pm
  A     Uppercase Ante meridiem and Post meridiem                                 AM or PM
  g     12-hour format of an hour without leading zeros                           1 to 12
  G     24-hour format of an hour without leading zeros                           0 to 23
  h     12-hour format of an hour with leading zeros                              01 to 12
  H     24-hour format of an hour with leading zeros                              00 to 23
  i     Minutes, with leading zeros                                               00 to 59
  s     Seconds, with leading zeros                                               00 to 59
  u     Decimal fraction of a second                                              Examples:
        (minimum 1 digit, arbitrary number of digits allowed)                     001 (i.e. 0.001s) or
                                                                                  100 (i.e. 0.100s) or
                                                                                  999 (i.e. 0.999s) or
                                                                                  999876543210 (i.e. 0.999876543210s)
  O     Difference to Greenwich time (GMT) in hours and minutes                   Example: +1030
  P     Difference to Greenwich time (GMT) with colon between hours and minutes   Example: -08:00
  T     Timezone abbreviation of the machine running the code                     Examples: EST, MDT, PDT ...
  Z     Timezone offset in seconds (negative if west of UTC, positive if east)    -43200 to 50400
  c     ISO 8601 date
        Notes:                                                                    Examples:
        1) If unspecified, the month / day defaults to the current month / day,   1991 or
           the time defaults to midnight, while the timezone defaults to the      1992-10 or
           browser's timezone. If a time is specified, it must include both hours 1993-09-20 or
           and minutes. The &quot;T&quot; delimiter, seconds, milliseconds and timezone     1994-08-19T16:20+01:00 or
           are optional.                                                          1995-07-18T17:21:28-02:00 or
        2) The decimal fraction of a second, if specified, must contain at        1996-06-17T18:22:29.98765+03:00 or
           least 1 digit (there is no limit to the maximum number                 1997-05-16T19:23:30,12345-0400 or
           of digits allowed), and may be delimited by either a '.' or a ','      1998-04-15T20:24:31.2468Z or
        Refer to the examples on the right for the various levels of              1999-03-14T20:24:32Z or
        date-time granularity which are supported, or see                         2000-02-13T21:25:33
        http://www.w3.org/TR/NOTE-datetime for more info.                         2001-01-12 22:26:34
  U     Seconds since the Unix Epoch (January 1 1970 00:00:00 GMT)                1193432466 or -2138434463
  MS    Microsoft AJAX serialized dates                                           \/Date(1238606590509)\/ (i.e. UTC milliseconds since epoch) or
                                                                                  \/Date(1238606590509+0800)\/
&lt;/pre&gt;
 *
 * Example usage (note that you must escape format specifiers with '\\' to render them as character literals):
 * &lt;pre&gt;&lt;code&gt;
// Sample date:
// 'Wed Jan 10 2007 15:05:01 GMT-0600 (Central Standard Time)'

var dt = new Date('1/10/2007 03:05:01 PM GMT-0600');
console.log(Ext.Date.format(dt, 'Y-m-d'));                          // 2007-01-10
console.log(Ext.Date.format(dt, 'F j, Y, g:i a'));                  // January 10, 2007, 3:05 pm
console.log(Ext.Date.format(dt, 'l, \\t\\he jS \\of F Y h:i:s A')); // Wednesday, the 10th of January 2007 03:05:01 PM
&lt;/code&gt;&lt;/pre&gt;
 *
 * Here are some standard date/time patterns that you might find helpful.  They
 * are not part of the source of Ext.Date, but to use them you can simply copy this
 * block of code into any script that is included after Ext.Date and they will also become
 * globally available on the Date object.  Feel free to add or remove patterns as needed in your code.
 * &lt;pre&gt;&lt;code&gt;
Ext.Date.patterns = {
    ISO8601Long:&quot;Y-m-d H:i:s&quot;,
    ISO8601Short:&quot;Y-m-d&quot;,
    ShortDate: &quot;n/j/Y&quot;,
    LongDate: &quot;l, F d, Y&quot;,
    FullDateTime: &quot;l, F d, Y g:i:s A&quot;,
    MonthDay: &quot;F d&quot;,
    ShortTime: &quot;g:i A&quot;,
    LongTime: &quot;g:i:s A&quot;,
    SortableDateTime: &quot;Y-m-d\\TH:i:s&quot;,
    UniversalSortableDateTime: &quot;Y-m-d H:i:sO&quot;,
    YearMonth: &quot;F, Y&quot;
};
&lt;/code&gt;&lt;/pre&gt;
 *
 * Example usage:
 * &lt;pre&gt;&lt;code&gt;
var dt = new Date();
console.log(Ext.Date.format(dt, Ext.Date.patterns.ShortDate));
&lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;Developer-written, custom formats may be used by supplying both a formatting and a parsing function
 * which perform to specialized requirements. The functions are stored in {@link #parseFunctions} and {@link #formatFunctions}.&lt;/p&gt;
 * @singleton
 */</span>

/*
 * Most of the date-formatting functions below are the excellent work of Baron Schwartz.
 * (see http://www.xaprb.com/blog/2005/12/12/javascript-closures-for-runtime-efficiency/)
 * They generate precompiled functions from format patterns instead of parsing and
 * processing each pattern every time a date is formatted. These functions are available
 * on every Date object.
 */

//(function() {
//
//// create private copy of Ext's Ext.util.Format.format() method
//// - to remove unnecessary dependency
//// - to resolve namespace conflict with MS-Ajax's implementation
//function xf(format) {
//    var args = Array.prototype.slice.call(arguments, 1);
//    return format.replace(/\{(\d+)\}/g, function(m, i) {
//        return args[i];
//    });
//}
//
//Ext.Date = {
//    /**
//     * Returns the current timestamp
//     * @return {Date} The current timestamp
//     * @method
//     */
//    now: Date.now || function() {
//        return +new Date();
//    },
//
//    /**
//     * @private
//     * Private for now
//     */
//    toString: function(date) {
//        var pad = Ext.String.leftPad;
//
//        return date.getFullYear() + &quot;-&quot;
//            + pad(date.getMonth() + 1, 2, '0') + &quot;-&quot;
//            + pad(date.getDate(), 2, '0') + &quot;T&quot;
//            + pad(date.getHours(), 2, '0') + &quot;:&quot;
//            + pad(date.getMinutes(), 2, '0') + &quot;:&quot;
//            + pad(date.getSeconds(), 2, '0');
//    },
//
//    /**
//     * Returns the number of milliseconds between two dates
//     * @param {Date} dateA The first date
//     * @param {Date} dateB (optional) The second date, defaults to now
//     * @return {Number} The difference in milliseconds
//     */
//    getElapsed: function(dateA, dateB) {
//        return Math.abs(dateA - (dateB || new Date()));
//    },
//
//    /**
//     * Global flag which determines if strict date parsing should be used.
//     * Strict date parsing will not roll-over invalid dates, which is the
//     * default behaviour of javascript Date objects.
//     * (see {@link #parse} for more information)
//     * Defaults to &lt;tt&gt;false&lt;/tt&gt;.
//     * @static
//     * @type Boolean
//    */
//    useStrict: false,
//
//    // private
//    formatCodeToRegex: function(character, currentGroup) {
//        // Note: currentGroup - position in regex result array (see notes for Ext.Date.parseCodes below)
//        var p = utilDate.parseCodes[character];
//
//        if (p) {
//          p = typeof p == 'function'? p() : p;
//          utilDate.parseCodes[character] = p; // reassign function result to prevent repeated execution
//        }
//
//        return p ? Ext.applyIf({
//          c: p.c ? xf(p.c, currentGroup || &quot;{0}&quot;) : p.c
//        }, p) : {
//            g: 0,
//            c: null,
//            s: Ext.String.escapeRegex(character) // treat unrecognised characters as literals
//        };
//    },
//
//    /**
//     * &lt;p&gt;An object hash in which each property is a date parsing function. The property name is the
//     * format string which that function parses.&lt;/p&gt;
//     * &lt;p&gt;This object is automatically populated with date parsing functions as
//     * date formats are requested for Ext standard formatting strings.&lt;/p&gt;
//     * &lt;p&gt;Custom parsing functions may be inserted into this object, keyed by a name which from then on
//     * may be used as a format string to {@link #parse}.&lt;p&gt;
//     * &lt;p&gt;Example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;
//Ext.Date.parseFunctions['x-date-format'] = myDateParser;
//&lt;/code&gt;&lt;/pre&gt;
//     * &lt;p&gt;A parsing function should return a Date object, and is passed the following parameters:&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
//     * &lt;li&gt;&lt;code&gt;date&lt;/code&gt; : String&lt;div class=&quot;sub-desc&quot;&gt;The date string to parse.&lt;/div&gt;&lt;/li&gt;
//     * &lt;li&gt;&lt;code&gt;strict&lt;/code&gt; : Boolean&lt;div class=&quot;sub-desc&quot;&gt;True to validate date strings while parsing
//     * (i.e. prevent javascript Date &quot;rollover&quot;) (The default must be false).
//     * Invalid date strings should return null when parsed.&lt;/div&gt;&lt;/li&gt;
//     * &lt;/ul&gt;&lt;/div&gt;&lt;/p&gt;
//     * &lt;p&gt;To enable Dates to also be &lt;i&gt;formatted&lt;/i&gt; according to that format, a corresponding
//     * formatting function must be placed into the {@link #formatFunctions} property.
//     * @property parseFunctions
//     * @static
//     * @type Object
//     */
//    parseFunctions: {
//        &quot;MS&quot;: function(input, strict) {
//            // note: the timezone offset is ignored since the MS Ajax server sends
//            // a UTC milliseconds-since-Unix-epoch value (negative values are allowed)
//            var re = new RegExp('\\/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\/');
//            var r = (input || '').match(re);
//            return r? new Date(((r[1] || '') + r[2]) * 1) : null;
//        }
//    },
//    parseRegexes: [],
//
//    /**
//     * &lt;p&gt;An object hash in which each property is a date formatting function. The property name is the
//     * format string which corresponds to the produced formatted date string.&lt;/p&gt;
//     * &lt;p&gt;This object is automatically populated with date formatting functions as
//     * date formats are requested for Ext standard formatting strings.&lt;/p&gt;
//     * &lt;p&gt;Custom formatting functions may be inserted into this object, keyed by a name which from then on
//     * may be used as a format string to {@link #format}. Example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;
//Ext.Date.formatFunctions['x-date-format'] = myDateFormatter;
//&lt;/code&gt;&lt;/pre&gt;
//     * &lt;p&gt;A formatting function should return a string representation of the passed Date object, and is passed the following parameters:&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
//     * &lt;li&gt;&lt;code&gt;date&lt;/code&gt; : Date&lt;div class=&quot;sub-desc&quot;&gt;The Date to format.&lt;/div&gt;&lt;/li&gt;
//     * &lt;/ul&gt;&lt;/div&gt;&lt;/p&gt;
//     * &lt;p&gt;To enable date strings to also be &lt;i&gt;parsed&lt;/i&gt; according to that format, a corresponding
//     * parsing function must be placed into the {@link #parseFunctions} property.
//     * @property formatFunctions
//     * @static
//     * @type Object
//     */
//    formatFunctions: {
//        &quot;MS&quot;: function() {
//            // UTC milliseconds since Unix epoch (MS-AJAX serialized date format (MRSF))
//            return '\\/Date(' + this.getTime() + ')\\/';
//        }
//    },
//
//    y2kYear : 50,
//
//    /**
//     * Date interval constant
//     * @static
//     * @type String
//     */
//    MILLI : &quot;ms&quot;,
//
//    /**
//     * Date interval constant
//     * @static
//     * @type String
//     */
//    SECOND : &quot;s&quot;,
//
//    /**
//     * Date interval constant
//     * @static
//     * @type String
//     */
//    MINUTE : &quot;mi&quot;,
//
//    /** Date interval constant
//     * @static
//     * @type String
//     */
//    HOUR : &quot;h&quot;,
//
//    /**
//     * Date interval constant
//     * @static
//     * @type String
//     */
//    DAY : &quot;d&quot;,
//
//    /**
//     * Date interval constant
//     * @static
//     * @type String
//     */
//    MONTH : &quot;mo&quot;,
//
//    /**
//     * Date interval constant
//     * @static
//     * @type String
//     */
//    YEAR : &quot;y&quot;,
//
//    /**
//     * &lt;p&gt;An object hash containing default date values used during date parsing.&lt;/p&gt;
//     * &lt;p&gt;The following properties are available:&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
//     * &lt;li&gt;&lt;code&gt;y&lt;/code&gt; : Number&lt;div class=&quot;sub-desc&quot;&gt;The default year value. (defaults to undefined)&lt;/div&gt;&lt;/li&gt;
//     * &lt;li&gt;&lt;code&gt;m&lt;/code&gt; : Number&lt;div class=&quot;sub-desc&quot;&gt;The default 1-based month value. (defaults to undefined)&lt;/div&gt;&lt;/li&gt;
//     * &lt;li&gt;&lt;code&gt;d&lt;/code&gt; : Number&lt;div class=&quot;sub-desc&quot;&gt;The default day value. (defaults to undefined)&lt;/div&gt;&lt;/li&gt;
//     * &lt;li&gt;&lt;code&gt;h&lt;/code&gt; : Number&lt;div class=&quot;sub-desc&quot;&gt;The default hour value. (defaults to undefined)&lt;/div&gt;&lt;/li&gt;
//     * &lt;li&gt;&lt;code&gt;i&lt;/code&gt; : Number&lt;div class=&quot;sub-desc&quot;&gt;The default minute value. (defaults to undefined)&lt;/div&gt;&lt;/li&gt;
//     * &lt;li&gt;&lt;code&gt;s&lt;/code&gt; : Number&lt;div class=&quot;sub-desc&quot;&gt;The default second value. (defaults to undefined)&lt;/div&gt;&lt;/li&gt;
//     * &lt;li&gt;&lt;code&gt;ms&lt;/code&gt; : Number&lt;div class=&quot;sub-desc&quot;&gt;The default millisecond value. (defaults to undefined)&lt;/div&gt;&lt;/li&gt;
//     * &lt;/ul&gt;&lt;/div&gt;&lt;/p&gt;
//     * &lt;p&gt;Override these properties to customize the default date values used by the {@link #parse} method.&lt;/p&gt;
//     * &lt;p&gt;&lt;b&gt;Note: In countries which experience Daylight Saving Time (i.e. DST), the &lt;tt&gt;h&lt;/tt&gt;, &lt;tt&gt;i&lt;/tt&gt;, &lt;tt&gt;s&lt;/tt&gt;
//     * and &lt;tt&gt;ms&lt;/tt&gt; properties may coincide with the exact time in which DST takes effect.
//     * It is the responsiblity of the developer to account for this.&lt;/b&gt;&lt;/p&gt;
//     * Example Usage:
//     * &lt;pre&gt;&lt;code&gt;
//// set default day value to the first day of the month
//Ext.Date.defaults.d = 1;
//
//// parse a February date string containing only year and month values.
//// setting the default day value to 1 prevents weird date rollover issues
//// when attempting to parse the following date string on, for example, March 31st 2009.
//Ext.Date.parse('2009-02', 'Y-m'); // returns a Date object representing February 1st 2009
//&lt;/code&gt;&lt;/pre&gt;
//     * @property defaults
//     * @static
//     * @type Object
//     */
//    defaults: {},
//
//    /**
//     * An array of textual day names.
//     * Override these values for international dates.
//     * Example:
//     * &lt;pre&gt;&lt;code&gt;
//Ext.Date.dayNames = [
//    'SundayInYourLang',
//    'MondayInYourLang',
//    ...
//];
//&lt;/code&gt;&lt;/pre&gt;
//     * @type Array
//     * @static
//     */
//    dayNames : [
//        &quot;Sunday&quot;,
//        &quot;Monday&quot;,
//        &quot;Tuesday&quot;,
//        &quot;Wednesday&quot;,
//        &quot;Thursday&quot;,
//        &quot;Friday&quot;,
//        &quot;Saturday&quot;
//    ],
//
//    /**
//     * An array of textual month names.
//     * Override these values for international dates.
//     * Example:
//     * &lt;pre&gt;&lt;code&gt;
//Ext.Date.monthNames = [
//    'JanInYourLang',
//    'FebInYourLang',
//    ...
//];
//&lt;/code&gt;&lt;/pre&gt;
//     * @type Array
//     * @static
//     */
//    monthNames : [
//        &quot;January&quot;,
//        &quot;February&quot;,
//        &quot;March&quot;,
//        &quot;April&quot;,
//        &quot;May&quot;,
//        &quot;June&quot;,
//        &quot;July&quot;,
//        &quot;August&quot;,
//        &quot;September&quot;,
//        &quot;October&quot;,
//        &quot;November&quot;,
//        &quot;December&quot;
//    ],
//
//    /**
//     * An object hash of zero-based javascript month numbers (with short month names as keys. note: keys are case-sensitive).
//     * Override these values for international dates.
//     * Example:
//     * &lt;pre&gt;&lt;code&gt;
//Ext.Date.monthNumbers = {
//    'ShortJanNameInYourLang':0,
//    'ShortFebNameInYourLang':1,
//    ...
//};
//&lt;/code&gt;&lt;/pre&gt;
//     * @type Object
//     * @static
//     */
//    monthNumbers : {
//        Jan:0,
//        Feb:1,
//        Mar:2,
//        Apr:3,
//        May:4,
//        Jun:5,
//        Jul:6,
//        Aug:7,
//        Sep:8,
//        Oct:9,
//        Nov:10,
//        Dec:11
//    },
//    /**
//     * &lt;p&gt;The date format string that the {@link Ext.util.Format#dateRenderer}
//     * and {@link Ext.util.Format#date} functions use.  See {@link Ext.Date} for details.&lt;/p&gt;
//     * &lt;p&gt;This defaults to &lt;code&gt;m/d/Y&lt;/code&gt;, but may be overridden in a locale file.&lt;/p&gt;
//     * @property defaultFormat
//     * @static
//     * @type String
//     */
//    defaultFormat : &quot;m/d/Y&quot;,
//    /**
//     * Get the short month name for the given month number.
//     * Override this function for international dates.
//     * @param {Number} month A zero-based javascript month number.
//     * @return {String} The short month name.
//     * @static
//     */
//    getShortMonthName : function(month) {
//        return utilDate.monthNames[month].substring(0, 3);
//    },
//
//    /**
//     * Get the short day name for the given day number.
//     * Override this function for international dates.
//     * @param {Number} day A zero-based javascript day number.
//     * @return {String} The short day name.
//     * @static
//     */
//    getShortDayName : function(day) {
//        return utilDate.dayNames[day].substring(0, 3);
//    },
//
//    /**
//     * Get the zero-based javascript month number for the given short/full month name.
//     * Override this function for international dates.
//     * @param {String} name The short/full month name.
//     * @return {Number} The zero-based javascript month number.
//     * @static
//     */
//    getMonthNumber : function(name) {
//        // handle camel casing for english month names (since the keys for the Ext.Date.monthNumbers hash are case sensitive)
//        return utilDate.monthNumbers[name.substring(0, 1).toUpperCase() + name.substring(1, 3).toLowerCase()];
//    },
//
//    /**
//     * Checks if the specified format contains hour information
//     * @param {String} format The format to check
//     * @return {Boolean} True if the format contains hour information
//     * @static
//     * @method
//     */
//    formatContainsHourInfo : (function(){
//        var stripEscapeRe = /(\\.)/g,
//            hourInfoRe = /([gGhHisucUOPZ]|MS)/;
//        return function(format){
//            return hourInfoRe.test(format.replace(stripEscapeRe, ''));
//        };
//    })(),
//
//    /**
//     * Checks if the specified format contains information about
//     * anything other than the time.
//     * @param {String} format The format to check
//     * @return {Boolean} True if the format contains information about
//     * date/day information.
//     * @static
//     * @method
//     */
//    formatContainsDateInfo : (function(){
//        var stripEscapeRe = /(\\.)/g,
//            dateInfoRe = /([djzmnYycU]|MS)/;
//
//        return function(format){
//            return dateInfoRe.test(format.replace(stripEscapeRe, ''));
//        };
//    })(),
//
//    /**
//     * The base format-code to formatting-function hashmap used by the {@link #format} method.
//     * Formatting functions are strings (or functions which return strings) which
//     * will return the appropriate value when evaluated in the context of the Date object
//     * from which the {@link #format} method is called.
//     * Add to / override these mappings for custom date formatting.
//     * Note: Ext.Date.format() treats characters as literals if an appropriate mapping cannot be found.
//     * Example:
//     * &lt;pre&gt;&lt;code&gt;
//Ext.Date.formatCodes.x = &quot;Ext.util.Format.leftPad(this.getDate(), 2, '0')&quot;;
//console.log(Ext.Date.format(new Date(), 'X'); // returns the current day of the month
//&lt;/code&gt;&lt;/pre&gt;
//     * @type Object
//     * @static
//     */
//    formatCodes : {
//        d: &quot;Ext.String.leftPad(this.getDate(), 2, '0')&quot;,
//        D: &quot;Ext.Date.getShortDayName(this.getDay())&quot;, // get localised short day name
//        j: &quot;this.getDate()&quot;,
//        l: &quot;Ext.Date.dayNames[this.getDay()]&quot;,
//        N: &quot;(this.getDay() ? this.getDay() : 7)&quot;,
//        S: &quot;Ext.Date.getSuffix(this)&quot;,
//        w: &quot;this.getDay()&quot;,
//        z: &quot;Ext.Date.getDayOfYear(this)&quot;,
//        W: &quot;Ext.String.leftPad(Ext.Date.getWeekOfYear(this), 2, '0')&quot;,
//        F: &quot;Ext.Date.monthNames[this.getMonth()]&quot;,
//        m: &quot;Ext.String.leftPad(this.getMonth() + 1, 2, '0')&quot;,
//        M: &quot;Ext.Date.getShortMonthName(this.getMonth())&quot;, // get localised short month name
//        n: &quot;(this.getMonth() + 1)&quot;,
//        t: &quot;Ext.Date.getDaysInMonth(this)&quot;,
//        L: &quot;(Ext.Date.isLeapYear(this) ? 1 : 0)&quot;,
//        o: &quot;(this.getFullYear() + (Ext.Date.getWeekOfYear(this) == 1 &amp;&amp; this.getMonth() &gt; 0 ? +1 : (Ext.Date.getWeekOfYear(this) &gt;= 52 &amp;&amp; this.getMonth() &lt; 11 ? -1 : 0)))&quot;,
//        Y: &quot;Ext.String.leftPad(this.getFullYear(), 4, '0')&quot;,
//        y: &quot;('' + this.getFullYear()).substring(2, 4)&quot;,
//        a: &quot;(this.getHours() &lt; 12 ? 'am' : 'pm')&quot;,
//        A: &quot;(this.getHours() &lt; 12 ? 'AM' : 'PM')&quot;,
//        g: &quot;((this.getHours() % 12) ? this.getHours() % 12 : 12)&quot;,
//        G: &quot;this.getHours()&quot;,
//        h: &quot;Ext.String.leftPad((this.getHours() % 12) ? this.getHours() % 12 : 12, 2, '0')&quot;,
//        H: &quot;Ext.String.leftPad(this.getHours(), 2, '0')&quot;,
//        i: &quot;Ext.String.leftPad(this.getMinutes(), 2, '0')&quot;,
//        s: &quot;Ext.String.leftPad(this.getSeconds(), 2, '0')&quot;,
//        u: &quot;Ext.String.leftPad(this.getMilliseconds(), 3, '0')&quot;,
//        O: &quot;Ext.Date.getGMTOffset(this)&quot;,
//        P: &quot;Ext.Date.getGMTOffset(this, true)&quot;,
//        T: &quot;Ext.Date.getTimezone(this)&quot;,
//        Z: &quot;(this.getTimezoneOffset() * -60)&quot;,
//
//        c: function() { // ISO-8601 -- GMT format
//            for (var c = &quot;Y-m-dTH:i:sP&quot;, code = [], i = 0, l = c.length; i &lt; l; ++i) {
//                var e = c.charAt(i);
//                code.push(e == &quot;T&quot; ? &quot;'T'&quot; : utilDate.getFormatCode(e)); // treat T as a character literal
//            }
//            return code.join(&quot; + &quot;);
//        },
//        /*
//        c: function() { // ISO-8601 -- UTC format
//            return [
//              &quot;this.getUTCFullYear()&quot;, &quot;'-'&quot;,
//              &quot;Ext.util.Format.leftPad(this.getUTCMonth() + 1, 2, '0')&quot;, &quot;'-'&quot;,
//              &quot;Ext.util.Format.leftPad(this.getUTCDate(), 2, '0')&quot;,
//              &quot;'T'&quot;,
//              &quot;Ext.util.Format.leftPad(this.getUTCHours(), 2, '0')&quot;, &quot;':'&quot;,
//              &quot;Ext.util.Format.leftPad(this.getUTCMinutes(), 2, '0')&quot;, &quot;':'&quot;,
//              &quot;Ext.util.Format.leftPad(this.getUTCSeconds(), 2, '0')&quot;,
//              &quot;'Z'&quot;
//            ].join(&quot; + &quot;);
//        },
//        */
//
//        U: &quot;Math.round(this.getTime() / 1000)&quot;
//    },
//
//    /**
//     * Parses the passed string using the specified date format.
//     * Note that this function expects normal calendar dates, meaning that months are 1-based (i.e. 1 = January).
//     * The {@link #defaults} hash will be used for any date value (i.e. year, month, day, hour, minute, second or millisecond)
//     * which cannot be found in the passed string. If a corresponding default date value has not been specified in the {@link #defaults} hash,
//     * the current date's year, month, day or DST-adjusted zero-hour time value will be used instead.
//     * Keep in mind that the input date string must precisely match the specified format string
//     * in order for the parse operation to be successful (failed parse operations return a null value).
//     * &lt;p&gt;Example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;
////dt = Fri May 25 2007 (current date)
//var dt = new Date();
//
////dt = Thu May 25 2006 (today&amp;#39;s month/day in 2006)
//dt = Ext.Date.parse(&quot;2006&quot;, &quot;Y&quot;);
//
////dt = Sun Jan 15 2006 (all date parts specified)
//dt = Ext.Date.parse(&quot;2006-01-15&quot;, &quot;Y-m-d&quot;);
//
////dt = Sun Jan 15 2006 15:20:01
//dt = Ext.Date.parse(&quot;2006-01-15 3:20:01 PM&quot;, &quot;Y-m-d g:i:s A&quot;);
//
//// attempt to parse Sun Feb 29 2006 03:20:01 in strict mode
//dt = Ext.Date.parse(&quot;2006-02-29 03:20:01&quot;, &quot;Y-m-d H:i:s&quot;, true); // returns null
//&lt;/code&gt;&lt;/pre&gt;
//     * @param {String} input The raw date string.
//     * @param {String} format The expected date string format.
//     * @param {Boolean} strict (optional) True to validate date strings while parsing (i.e. prevents javascript Date &quot;rollover&quot;)
//                        (defaults to false). Invalid date strings will return null when parsed.
//     * @return {Date} The parsed Date.
//     * @static
//     */
//    parse : function(input, format, strict) {
//        var p = utilDate.parseFunctions;
//        if (p[format] == null) {
//            utilDate.createParser(format);
//        }
//        return p[format](input, Ext.isDefined(strict) ? strict : utilDate.useStrict);
//    },
//
//    // Backwards compat
//    parseDate: function(input, format, strict){
//        return utilDate.parse(input, format, strict);
//    },
//
//
//    // private
//    getFormatCode : function(character) {
//        var f = utilDate.formatCodes[character];
//
//        if (f) {
//          f = typeof f == 'function'? f() : f;
//          utilDate.formatCodes[character] = f; // reassign function result to prevent repeated execution
//        }
//
//        // note: unknown characters are treated as literals
//        return f || (&quot;'&quot; + Ext.String.escape(character) + &quot;'&quot;);
//    },
//
//    // private
//    createFormat : function(format) {
//        var code = [],
//            special = false,
//            ch = '';
//
//        for (var i = 0; i &lt; format.length; ++i) {
//            ch = format.charAt(i);
//            if (!special &amp;&amp; ch == &quot;\\&quot;) {
//                special = true;
//            } else if (special) {
//                special = false;
//                code.push(&quot;'&quot; + Ext.String.escape(ch) + &quot;'&quot;);
//            } else {
//                code.push(utilDate.getFormatCode(ch));
//            }
//        }
//        utilDate.formatFunctions[format] = Ext.functionFactory(&quot;return &quot; + code.join('+'));
//    },
//
//    // private
//    createParser : (function() {
//        var code = [
//            &quot;var dt, y, m, d, h, i, s, ms, o, z, zz, u, v,&quot;,
//                &quot;def = Ext.Date.defaults,&quot;,
//                &quot;results = String(input).match(Ext.Date.parseRegexes[{0}]);&quot;, // either null, or an array of matched strings
//
//            &quot;if(results){&quot;,
//                &quot;{1}&quot;,
//
//                &quot;if(u != null){&quot;, // i.e. unix time is defined
//                    &quot;v = new Date(u * 1000);&quot;, // give top priority to UNIX time
//                &quot;}else{&quot;,
//                    // create Date object representing midnight of the current day;
//                    // this will provide us with our date defaults
//                    // (note: clearTime() handles Daylight Saving Time automatically)
//                    &quot;dt = Ext.Date.clearTime(new Date);&quot;,
//
//                    // date calculations (note: these calculations create a dependency on Ext.Number.from())
//                    &quot;y = Ext.Number.from(y, Ext.Number.from(def.y, dt.getFullYear()));&quot;,
//                    &quot;m = Ext.Number.from(m, Ext.Number.from(def.m - 1, dt.getMonth()));&quot;,
//                    &quot;d = Ext.Number.from(d, Ext.Number.from(def.d, dt.getDate()));&quot;,
//
//                    // time calculations (note: these calculations create a dependency on Ext.Number.from())
//                    &quot;h  = Ext.Number.from(h, Ext.Number.from(def.h, dt.getHours()));&quot;,
//                    &quot;i  = Ext.Number.from(i, Ext.Number.from(def.i, dt.getMinutes()));&quot;,
//                    &quot;s  = Ext.Number.from(s, Ext.Number.from(def.s, dt.getSeconds()));&quot;,
//                    &quot;ms = Ext.Number.from(ms, Ext.Number.from(def.ms, dt.getMilliseconds()));&quot;,
//
//                    &quot;if(z &gt;= 0 &amp;&amp; y &gt;= 0){&quot;,
//                        // both the year and zero-based day of year are defined and &gt;= 0.
//                        // these 2 values alone provide sufficient info to create a full date object
//
//                        // create Date object representing January 1st for the given year
//                        // handle years &lt; 100 appropriately
//                        &quot;v = Ext.Date.add(new Date(y &lt; 100 ? 100 : y, 0, 1, h, i, s, ms), Ext.Date.YEAR, y &lt; 100 ? y - 100 : 0);&quot;,
//
//                        // then add day of year, checking for Date &quot;rollover&quot; if necessary
//                        &quot;v = !strict? v : (strict === true &amp;&amp; (z &lt;= 364 || (Ext.Date.isLeapYear(v) &amp;&amp; z &lt;= 365))? Ext.Date.add(v, Ext.Date.DAY, z) : null);&quot;,
//                    &quot;}else if(strict === true &amp;&amp; !Ext.Date.isValid(y, m + 1, d, h, i, s, ms)){&quot;, // check for Date &quot;rollover&quot;
//                        &quot;v = null;&quot;, // invalid date, so return null
//                    &quot;}else{&quot;,
//                        // plain old Date object
//                        // handle years &lt; 100 properly
//                        &quot;v = Ext.Date.add(new Date(y &lt; 100 ? 100 : y, m, d, h, i, s, ms), Ext.Date.YEAR, y &lt; 100 ? y - 100 : 0);&quot;,
//                    &quot;}&quot;,
//                &quot;}&quot;,
//            &quot;}&quot;,
//
//            &quot;if(v){&quot;,
//                // favour UTC offset over GMT offset
//                &quot;if(zz != null){&quot;,
//                    // reset to UTC, then add offset
//                    &quot;v = Ext.Date.add(v, Ext.Date.SECOND, -v.getTimezoneOffset() * 60 - zz);&quot;,
//                &quot;}else if(o){&quot;,
//                    // reset to GMT, then add offset
//                    &quot;v = Ext.Date.add(v, Ext.Date.MINUTE, -v.getTimezoneOffset() + (sn == '+'? -1 : 1) * (hr * 60 + mn));&quot;,
//                &quot;}&quot;,
//            &quot;}&quot;,
//
//            &quot;return v;&quot;
//        ].join('\n');
//
//        return function(format) {
//            var regexNum = utilDate.parseRegexes.length,
//                currentGroup = 1,
//                calc = [],
//                regex = [],
//                special = false,
//                ch = &quot;&quot;;
//
//            for (var i = 0; i &lt; format.length; ++i) {
//                ch = format.charAt(i);
//                if (!special &amp;&amp; ch == &quot;\\&quot;) {
//                    special = true;
//                } else if (special) {
//                    special = false;
//                    regex.push(Ext.String.escape(ch));
//                } else {
//                    var obj = utilDate.formatCodeToRegex(ch, currentGroup);
//                    currentGroup += obj.g;
//                    regex.push(obj.s);
//                    if (obj.g &amp;&amp; obj.c) {
//                        calc.push(obj.c);
//                    }
//                }
//            }
//
//            utilDate.parseRegexes[regexNum] = new RegExp(&quot;^&quot; + regex.join('') + &quot;$&quot;, 'i');
//            utilDate.parseFunctions[format] = Ext.functionFactory(&quot;input&quot;, &quot;strict&quot;, xf(code, regexNum, calc.join('')));
//        };
//    })(),
//
//    // private
//    parseCodes : {
//        /*
//         * Notes:
//         * g = {Number} calculation group (0 or 1. only group 1 contributes to date calculations.)
//         * c = {String} calculation method (required for group 1. null for group 0. {0} = currentGroup - position in regex result array)
//         * s = {String} regex pattern. all matches are stored in results[], and are accessible by the calculation mapped to 'c'
//         */
//        d: {
//            g:1,
//            c:&quot;d = parseInt(results[{0}], 10);\n&quot;,
//            s:&quot;(\\d{2})&quot; // day of month with leading zeroes (01 - 31)
//        },
//        j: {
//            g:1,
//            c:&quot;d = parseInt(results[{0}], 10);\n&quot;,
//            s:&quot;(\\d{1,2})&quot; // day of month without leading zeroes (1 - 31)
//        },
//        D: function() {
//            for (var a = [], i = 0; i &lt; 7; a.push(utilDate.getShortDayName(i)), ++i); // get localised short day names
//            return {
//                g:0,
//                c:null,
//                s:&quot;(?:&quot; + a.join(&quot;|&quot;) +&quot;)&quot;
//            };
//        },
//        l: function() {
//            return {
//                g:0,
//                c:null,
//                s:&quot;(?:&quot; + utilDate.dayNames.join(&quot;|&quot;) + &quot;)&quot;
//            };
//        },
//        N: {
//            g:0,
//            c:null,
//            s:&quot;[1-7]&quot; // ISO-8601 day number (1 (monday) - 7 (sunday))
//        },
//        S: {
//            g:0,
//            c:null,
//            s:&quot;(?:st|nd|rd|th)&quot;
//        },
//        w: {
//            g:0,
//            c:null,
//            s:&quot;[0-6]&quot; // javascript day number (0 (sunday) - 6 (saturday))
//        },
//        z: {
//            g:1,
//            c:&quot;z = parseInt(results[{0}], 10);\n&quot;,
//            s:&quot;(\\d{1,3})&quot; // day of the year (0 - 364 (365 in leap years))
//        },
//        W: {
//            g:0,
//            c:null,
//            s:&quot;(?:\\d{2})&quot; // ISO-8601 week number (with leading zero)
//        },
//        F: function() {
//            return {
//                g:1,
//                c:&quot;m = parseInt(Ext.Date.getMonthNumber(results[{0}]), 10);\n&quot;, // get localised month number
//                s:&quot;(&quot; + utilDate.monthNames.join(&quot;|&quot;) + &quot;)&quot;
//            };
//        },
//        M: function() {
//            for (var a = [], i = 0; i &lt; 12; a.push(utilDate.getShortMonthName(i)), ++i); // get localised short month names
//            return Ext.applyIf({
//                s:&quot;(&quot; + a.join(&quot;|&quot;) + &quot;)&quot;
//            }, utilDate.formatCodeToRegex(&quot;F&quot;));
//        },
//        m: {
//            g:1,
//            c:&quot;m = parseInt(results[{0}], 10) - 1;\n&quot;,
//            s:&quot;(\\d{2})&quot; // month number with leading zeros (01 - 12)
//        },
//        n: {
//            g:1,
//            c:&quot;m = parseInt(results[{0}], 10) - 1;\n&quot;,
//            s:&quot;(\\d{1,2})&quot; // month number without leading zeros (1 - 12)
//        },
//        t: {
//            g:0,
//            c:null,
//            s:&quot;(?:\\d{2})&quot; // no. of days in the month (28 - 31)
//        },
//        L: {
//            g:0,
//            c:null,
//            s:&quot;(?:1|0)&quot;
//        },
//        o: function() {
//            return utilDate.formatCodeToRegex(&quot;Y&quot;);
//        },
//        Y: {
//            g:1,
//            c:&quot;y = parseInt(results[{0}], 10);\n&quot;,
//            s:&quot;(\\d{4})&quot; // 4-digit year
//        },
//        y: {
//            g:1,
//            c:&quot;var ty = parseInt(results[{0}], 10);\n&quot;
//                + &quot;y = ty &gt; Ext.Date.y2kYear ? 1900 + ty : 2000 + ty;\n&quot;, // 2-digit year
//            s:&quot;(\\d{1,2})&quot;
//        },
//        /*
//         * In the am/pm parsing routines, we allow both upper and lower case
//         * even though it doesn't exactly match the spec. It gives much more flexibility
//         * in being able to specify case insensitive regexes.
//         */
//        a: {
//            g:1,
//            c:&quot;if (/(am)/i.test(results[{0}])) {\n&quot;
//                + &quot;if (!h || h == 12) { h = 0; }\n&quot;
//                + &quot;} else { if (!h || h &lt; 12) { h = (h || 0) + 12; }}&quot;,
//            s:&quot;(am|pm|AM|PM)&quot;
//        },
//        A: {
//            g:1,
//            c:&quot;if (/(am)/i.test(results[{0}])) {\n&quot;
//                + &quot;if (!h || h == 12) { h = 0; }\n&quot;
//                + &quot;} else { if (!h || h &lt; 12) { h = (h || 0) + 12; }}&quot;,
//            s:&quot;(AM|PM|am|pm)&quot;
//        },
//        g: function() {
//            return utilDate.formatCodeToRegex(&quot;G&quot;);
//        },
//        G: {
//            g:1,
//            c:&quot;h = parseInt(results[{0}], 10);\n&quot;,
//            s:&quot;(\\d{1,2})&quot; // 24-hr format of an hour without leading zeroes (0 - 23)
//        },
//        h: function() {
//            return utilDate.formatCodeToRegex(&quot;H&quot;);
//        },
//        H: {
//            g:1,
//            c:&quot;h = parseInt(results[{0}], 10);\n&quot;,
//            s:&quot;(\\d{2})&quot; //  24-hr format of an hour with leading zeroes (00 - 23)
//        },
//        i: {
//            g:1,
//            c:&quot;i = parseInt(results[{0}], 10);\n&quot;,
//            s:&quot;(\\d{2})&quot; // minutes with leading zeros (00 - 59)
//        },
//        s: {
//            g:1,
//            c:&quot;s = parseInt(results[{0}], 10);\n&quot;,
//            s:&quot;(\\d{2})&quot; // seconds with leading zeros (00 - 59)
//        },
//        u: {
//            g:1,
//            c:&quot;ms = results[{0}]; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n&quot;,
//            s:&quot;(\\d+)&quot; // decimal fraction of a second (minimum = 1 digit, maximum = unlimited)
//        },
//        O: {
//            g:1,
//            c:[
//                &quot;o = results[{0}];&quot;,
//                &quot;var sn = o.substring(0,1),&quot;, // get + / - sign
//                    &quot;hr = o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),&quot;, // get hours (performs minutes-to-hour conversion also, just in case)
//                    &quot;mn = o.substring(3,5) % 60;&quot;, // get minutes
//                &quot;o = ((-12 &lt;= (hr*60 + mn)/60) &amp;&amp; ((hr*60 + mn)/60 &lt;= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n&quot; // -12hrs &lt;= GMT offset &lt;= 14hrs
//            ].join(&quot;\n&quot;),
//            s: &quot;([+\-]\\d{4})&quot; // GMT offset in hrs and mins
//        },
//        P: {
//            g:1,
//            c:[
//                &quot;o = results[{0}];&quot;,
//                &quot;var sn = o.substring(0,1),&quot;, // get + / - sign
//                    &quot;hr = o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),&quot;, // get hours (performs minutes-to-hour conversion also, just in case)
//                    &quot;mn = o.substring(4,6) % 60;&quot;, // get minutes
//                &quot;o = ((-12 &lt;= (hr*60 + mn)/60) &amp;&amp; ((hr*60 + mn)/60 &lt;= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n&quot; // -12hrs &lt;= GMT offset &lt;= 14hrs
//            ].join(&quot;\n&quot;),
//            s: &quot;([+\-]\\d{2}:\\d{2})&quot; // GMT offset in hrs and mins (with colon separator)
//        },
//        T: {
//            g:0,
//            c:null,
//            s:&quot;[A-Z]{1,4}&quot; // timezone abbrev. may be between 1 - 4 chars
//        },
//        Z: {
//            g:1,
//            c:&quot;zz = results[{0}] * 1;\n&quot; // -43200 &lt;= UTC offset &lt;= 50400
//                  + &quot;zz = (-43200 &lt;= zz &amp;&amp; zz &lt;= 50400)? zz : null;\n&quot;,
//            s:&quot;([+\-]?\\d{1,5})&quot; // leading '+' sign is optional for UTC offset
//        },
//        c: function() {
//            var calc = [],
//                arr = [
//                    utilDate.formatCodeToRegex(&quot;Y&quot;, 1), // year
//                    utilDate.formatCodeToRegex(&quot;m&quot;, 2), // month
//                    utilDate.formatCodeToRegex(&quot;d&quot;, 3), // day
//                    utilDate.formatCodeToRegex(&quot;h&quot;, 4), // hour
//                    utilDate.formatCodeToRegex(&quot;i&quot;, 5), // minute
//                    utilDate.formatCodeToRegex(&quot;s&quot;, 6), // second
//                    {c:&quot;ms = results[7] || '0'; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n&quot;}, // decimal fraction of a second (minimum = 1 digit, maximum = unlimited)
//                    {c:[ // allow either &quot;Z&quot; (i.e. UTC) or &quot;-0530&quot; or &quot;+08:00&quot; (i.e. UTC offset) timezone delimiters. assumes local timezone if no timezone is specified
//                        &quot;if(results[8]) {&quot;, // timezone specified
//                            &quot;if(results[8] == 'Z'){&quot;,
//                                &quot;zz = 0;&quot;, // UTC
//                            &quot;}else if (results[8].indexOf(':') &gt; -1){&quot;,
//                                utilDate.formatCodeToRegex(&quot;P&quot;, 8).c, // timezone offset with colon separator
//                            &quot;}else{&quot;,
//                                utilDate.formatCodeToRegex(&quot;O&quot;, 8).c, // timezone offset without colon separator
//                            &quot;}&quot;,
//                        &quot;}&quot;
//                    ].join('\n')}
//                ];
//
//            for (var i = 0, l = arr.length; i &lt; l; ++i) {
//                calc.push(arr[i].c);
//            }
//
//            return {
//                g:1,
//                c:calc.join(&quot;&quot;),
//                s:[
//                    arr[0].s, // year (required)
//                    &quot;(?:&quot;, &quot;-&quot;, arr[1].s, // month (optional)
//                        &quot;(?:&quot;, &quot;-&quot;, arr[2].s, // day (optional)
//                            &quot;(?:&quot;,
//                                &quot;(?:T| )?&quot;, // time delimiter -- either a &quot;T&quot; or a single blank space
//                                arr[3].s, &quot;:&quot;, arr[4].s,  // hour AND minute, delimited by a single colon (optional). MUST be preceded by either a &quot;T&quot; or a single blank space
//                                &quot;(?::&quot;, arr[5].s, &quot;)?&quot;, // seconds (optional)
//                                &quot;(?:(?:\\.|,)(\\d+))?&quot;, // decimal fraction of a second (e.g. &quot;,12345&quot; or &quot;.98765&quot;) (optional)
//                                &quot;(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?&quot;, // &quot;Z&quot; (UTC) or &quot;-0530&quot; (UTC offset without colon delimiter) or &quot;+08:00&quot; (UTC offset with colon delimiter) (optional)
//                            &quot;)?&quot;,
//                        &quot;)?&quot;,
//                    &quot;)?&quot;
//                ].join(&quot;&quot;)
//            };
//        },
//        U: {
//            g:1,
//            c:&quot;u = parseInt(results[{0}], 10);\n&quot;,
//            s:&quot;(-?\\d+)&quot; // leading minus sign indicates seconds before UNIX epoch
//        }
//    },
//
//    //Old Ext.Date prototype methods.
//    // private
//    dateFormat: function(date, format) {
//        return utilDate.format(date, format);
//    },
//
//    /**
//     * Formats a date given the supplied format string.
//     * @param {Date} date The date to format
//     * @param {String} format The format string
//     * @return {String} The formatted date
//     */
//    format: function(date, format) {
//        if (utilDate.formatFunctions[format] == null) {
//            utilDate.createFormat(format);
//        }
//        var result = utilDate.formatFunctions[format].call(date);
//        return result + '';
//    }  
//    })(),
//
//    //Maintains compatibility with old static and prototype window.Date methods.
//    compat: function() {
//        var nativeDate = window.Date,
//            p, u,
//            statics = ['useStrict', 'formatCodeToRegex', 'parseFunctions', 'parseRegexes', 'formatFunctions', 'y2kYear', 'MILLI', 'SECOND', 'MINUTE', 'HOUR', 'DAY', 'MONTH', 'YEAR', 'defaults', 'dayNames', 'monthNames', 'monthNumbers', 'getShortMonthName', 'getShortDayName', 'getMonthNumber', 'formatCodes', 'isValid', 'parseDate', 'getFormatCode', 'createFormat', 'createParser', 'parseCodes'],
//            proto = ['dateFormat', 'format', 'getTimezone', 'getGMTOffset', 'getDayOfYear', 'getWeekOfYear', 'isLeapYear', 'getFirstDayOfMonth', 'getLastDayOfMonth', 'getDaysInMonth', 'getSuffix', 'clone', 'isDST', 'clearTime', 'add', 'between'];
//
//        //Append statics
//        Ext.Array.forEach(statics, function(s) {
//            nativeDate[s] = utilDate[s];
//        });
//
//        //Append to prototype
//        Ext.Array.forEach(proto, function(s) {
//            nativeDate.prototype[s] = function() {
//                var args = Array.prototype.slice.call(arguments);
//                args.unshift(this);
//                return utilDate[s].apply(utilDate, args);
//            };
//        });
//    }
//};
//
//var utilDate = Ext.Date;
//
//})();
//



function formatTime(t) {
		             var nt = (new Date()).getTime(),
		             diff = Math.round((nt-parseInt(t))/1000),
		             mf = Math.floor;
		          var day = mf(diff/60/60/24)==0 ? '' : mf(diff/60/60/24)+'天',
		             hour = mf(diff/60/60%24)==0 ? '' : mf(diff/60/60%24)+'小时',
		             min = mf(diff/60%60)==0 ? '' : mf(diff/60%60)+'分',
		             sec = mf(diff%60)&lt;10?&quot;0&quot;+mf(diff%60)+'秒前':mf(diff%60)+'秒前',
				     res = day+hour+min+sec;
				  return res;
		       }</pre>
</body>
</html>
